<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Pierre Zemb&#x27;s Blog - rust</title>
    <subtitle>Pierre Zemb personal blog</subtitle>
    <link rel="self" type="application/atom+xml" href="https://pierrezemb.fr/tags/rust/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://pierrezemb.fr"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-09T00:00:00+00:00</updated>
    <id>https://pierrezemb.fr/tags/rust/atom.xml</id>
    <entry xml:lang="en">
        <title>Designing Rust FDB Workloads That Actually Find Bugs</title>
        <published>2025-12-09T00:00:00+00:00</published>
        <updated>2025-12-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/"/>
        <id>https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/</id>
        
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <category term="distributed-systems" schema="https://pierrezemb.fr/tags/" label="distributed-systems"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/">&lt;p&gt;After &lt;a href=&quot;&#x2F;posts&#x2F;diving-into-foundationdb-simulation&#x2F;&quot;&gt;one trillion CPU-hours of simulation testing&lt;&#x2F;a&gt;, FoundationDB has been stress-tested under conditions far worse than any production environment. Network partitions, disk failures, Byzantine faults. FDB handles them all. &lt;strong&gt;But what about your code?&lt;&#x2F;strong&gt; Your layer sits on top of FDB. Your indexes, your transaction logic, your retry handling. How do you know it survives chaos?&lt;&#x2F;p&gt;
&lt;p&gt;At Clever Cloud, we are building &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;materia&#x2F;&quot;&gt;Materia&lt;&#x2F;a&gt;, our serverless database product. The question haunted us: how do you ship layer code with the same confidence FDB has in its own? Our answer was to hack our way into FDB&#x27;s simulator using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;tree&#x2F;4ed057a&#x2F;foundationdb-simulation&quot;&gt;foundationdb-simulation&lt;&#x2F;a&gt;, a crate that compiles Rust to run inside FDB&#x27;s deterministic simulator. We&#x27;re the only language besides Flow that can pull this off.&lt;&#x2F;p&gt;
&lt;p&gt;The first seed triggered &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;developer-guide.html#transactions-with-unknown-results&quot;&gt;&lt;code&gt;commit_unknown_result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, one of the most feared edge cases for FDB layer developers. When a connection drops, the client can&#x27;t know if the transaction committed. Our atomic counters were incrementing twice. In production, this surfaces once every few months under heavy load and during failures. In simulation? &lt;strong&gt;Almost immediately.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This post won&#x27;t walk you through the code mechanics. The &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;foundationdb-simulation&quot;&gt;foundationdb-simulation crate&lt;&#x2F;a&gt; and its &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;tree&#x2F;4ed057a&#x2F;foundationdb-simulation&quot;&gt;README&lt;&#x2F;a&gt; cover that. Instead, this teaches you how to &lt;strong&gt;design&lt;&#x2F;strong&gt; workloads that catch real bugs. Whether you&#x27;re a junior engineer or an LLM helping write tests, these principles will guide you.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-autonomous-testing-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-autonomous-testing-works&quot; aria-label=&quot;Anchor link for: why-autonomous-testing-works&quot;&gt;üîó&lt;&#x2F;a&gt;Why Autonomous Testing Works&lt;&#x2F;h2&gt;
&lt;p&gt;Traditional testing has you write specific tests for scenarios you imagined. But as Will Wilson put it at &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eZ1mmqlq-mY&quot;&gt;Bug Bash 2025&lt;&#x2F;a&gt;: &lt;strong&gt;&quot;The most dangerous bugs occur in states you never imagined possible.&quot;&lt;&#x2F;strong&gt; The key insight of autonomous testing (what FDB&#x27;s simulation embodies) is that instead of writing tests, you write a &lt;strong&gt;test generator&lt;&#x2F;strong&gt;. If you ran it for infinite time, it would eventually produce all possible tests you could have written. You don&#x27;t have infinite time, so instead you get a probability distribution over all possible tests. And probability distributions are leaky: they cover cases you never would have thought to test.&lt;&#x2F;p&gt;
&lt;p&gt;This is why simulation finds bugs so fast. You&#x27;re not testing what you thought to test. You&#x27;re testing what the probability distribution happens to generate, which includes edge cases you&#x27;d never have written explicitly. Add fault injection (a probability distribution over all possible ways the world can conspire to screw you) and now you&#x27;re finding bugs that would take months or years to surface in production.&lt;&#x2F;p&gt;
&lt;p&gt;This is what got me interested in simulation in the first place: how do you test the things you see during on-call shifts? Those weird transient bugs at 3 AM, the race conditions that happen once a month, the edge cases you only discover when production is on fire. Simulation shifts that complexity from SRE time to SWE time. What was a 3 AM page becomes a daytime debugging session. What was a high-pressure incident becomes a reproducible test case you can bisect, rewind, and experiment with freely.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-sequential-luck-problem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-sequential-luck-problem&quot; aria-label=&quot;Anchor link for: the-sequential-luck-problem&quot;&gt;üîó&lt;&#x2F;a&gt;The Sequential Luck Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s why rare bugs are so hard to find: imagine a bug that requires three unlikely events in sequence. Each event has a 1&#x2F;1000 probability. Finding that bug requires 1&#x2F;1,000,000,000 attempts, roughly a billion tries with random testing. Research confirms this: &lt;a href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;osdi18&#x2F;presentation&#x2F;alquraan&quot;&gt;a study of network partition failures&lt;&#x2F;a&gt; found that 83% require 3+ events to manifest, 80% have catastrophic impact, and 21% cause permanent damage that persists after the partition heals. &lt;strong&gt;But here&#x27;s the good news for Rust workloads&lt;&#x2F;strong&gt;: you don&#x27;t solve this problem yourself. FDB&#x27;s simulation handles fault injection. BUGGIFY injects failures at arbitrary code points. Network partitions appear and disappear. Disks fail. Machines crash and restart. The simulator explores failure combinations that would take years to encounter in production.&lt;&#x2F;p&gt;
&lt;p&gt;Your job is different. You need to design operations that exercise interesting code paths. Not just reads and writes, but the edge cases your users will inevitably trigger. And you need to write invariants that CATCH bugs when simulation surfaces them. After a million injected faults, how do you prove your data is still correct? This division of labor is the key insight: FDB injects chaos, you verify correctness.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;designing-your-operation-alphabet&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#designing-your-operation-alphabet&quot; aria-label=&quot;Anchor link for: designing-your-operation-alphabet&quot;&gt;üîó&lt;&#x2F;a&gt;Designing Your Operation Alphabet&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;operation alphabet&lt;&#x2F;strong&gt; is the complete set of operations your workload can perform. This is where most workloads fail: they test happy paths with uniform distribution and miss the edge cases that break production. Think about three categories:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Normal operations&lt;&#x2F;strong&gt; with realistic weights. In production, maybe 80% of your traffic is reads, 15% is simple writes, 5% is complex updates. Your workload should reflect this, because bugs often hide in the interactions between operation types. A workload that runs 50% reads and 50% writes tests different code paths than one that runs 95% reads and 5% writes. Both might be valid, but they&#x27;ll find different bugs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Adversarial inputs&lt;&#x2F;strong&gt; that customers will inevitably send. Empty strings. Maximum-length values. Null bytes in the middle of strings. Unicode edge cases. Boundary integers (0, -1, MAX_INT). Customers never respect your API specs, so model the chaos they create.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Nemesis operations&lt;&#x2F;strong&gt; that break things on purpose. Delete random data mid-test. Clear ranges that &quot;shouldn&#x27;t&quot; be cleared. Crash batch jobs mid-execution to test recovery. Run compaction every operation instead of daily. Create conflict storms where multiple clients hammer the same key. Approach the 10MB transaction limit. These operations stress your error handling and recovery paths. The rare operations are where bugs hide. That batch job running once a day in production? In simulation, you&#x27;ll hit its partial-failure edge case in minutes, but only if your operation alphabet includes it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;designing-invariants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#designing-invariants&quot; aria-label=&quot;Anchor link for: designing-invariants&quot;&gt;üîó&lt;&#x2F;a&gt;Designing Invariants&lt;&#x2F;h2&gt;
&lt;p&gt;After simulation runs thousands of operations with injected faults, network partitions, and machine crashes, how do you know your data is still correct? Unlike FDB&#x27;s internal testing, Rust workloads can&#x27;t inject assertions at arbitrary code points. You verify correctness in the &lt;code&gt;check()&lt;&#x2F;code&gt; phase, after the chaos ends. The key question: &lt;strong&gt;&quot;After all this, how do I PROVE my data is still correct?&quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One critical tip: validate during &lt;code&gt;start()&lt;&#x2F;code&gt;, not just in &lt;code&gt;check()&lt;&#x2F;code&gt;.&lt;&#x2F;strong&gt; Don&#x27;t wait until the end to discover corruption. After each operation (or batch of operations), read back the data and verify it matches expectations. If you&#x27;re maintaining a counter, read it and check the bounds. If you&#x27;re building an index, query it immediately after insertion. Early validation catches bugs closer to their source, making debugging far easier. The &lt;code&gt;check()&lt;&#x2F;code&gt; phase is your final safety net, but continuous validation during execution is where you&#x27;ll catch most issues.&lt;&#x2F;p&gt;
&lt;p&gt;An invariant is just a property that must always hold, no matter what operations ran. If you&#x27;ve seen property-based testing, it&#x27;s the same idea: instead of &lt;code&gt;assertFalse(new User(GUEST).canUse(SAVED_CARD))&lt;&#x2F;code&gt;, you write &lt;code&gt;assertEquals(user.isAuthenticated(), user.canUse(SAVED_CARD))&lt;&#x2F;code&gt;. The first tests one case. The second tests a rule that holds for all cases.&lt;&#x2F;p&gt;
&lt;p&gt;Four patterns dominate invariant design:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Reference Models&lt;&#x2F;strong&gt; maintain an in-memory copy of expected state. Every operation updates both the database and the reference model. In &lt;code&gt;check()&lt;&#x2F;code&gt;, you compare them. If they diverge, something went wrong. Use &lt;code&gt;BTreeMap&lt;&#x2F;code&gt; (not &lt;code&gt;HashMap&lt;&#x2F;code&gt;) for deterministic iteration. This pattern works best for single-client workloads where you can track state locally.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Conservation Laws&lt;&#x2F;strong&gt; track quantities that must stay constant. Inventory transfers between warehouses shouldn&#x27;t change total inventory. Money transfers between accounts shouldn&#x27;t create or destroy money. Sum everything up and verify the conservation law holds. This pattern is elegant because it doesn&#x27;t require tracking individual operations, just the aggregate property.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Structural Integrity&lt;&#x2F;strong&gt; verifies data structures remain valid. If you maintain a secondary index, verify every index entry points to an existing record and every record appears in the index exactly once. If you maintain a linked list in FDB, traverse it and confirm every node is reachable. The cycle validation pattern (creating a circular list where nodes point to each other) is a classic technique from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;231f762&#x2F;fdbserver&#x2F;workloads&#x2F;Cycle.actor.cpp&quot;&gt;FDB&#x27;s own Cycle workload&lt;&#x2F;a&gt;. After chaos, traverse the cycle and verify you visit exactly N nodes.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Operation Logging&lt;&#x2F;strong&gt; solves two problems at once: &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; uncertainty and multi-client coordination. The trick from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;231f762&#x2F;fdbserver&#x2F;workloads&#x2F;AtomicOps.actor.cpp&quot;&gt;FDB&#x27;s own AtomicOps workload&lt;&#x2F;a&gt;: &lt;strong&gt;log the intent alongside the operation in the same transaction&lt;&#x2F;strong&gt;. Write both your operation AND a log entry recording what you intended. Since they&#x27;re in the same transaction, they either both commit or neither does. No uncertainty. For multi-client workloads, each client logs under its own prefix (e.g., &lt;code&gt;log&#x2F;{client_id}&#x2F;&lt;&#x2F;code&gt;). In &lt;code&gt;check()&lt;&#x2F;code&gt;, client 0 reads all logs from all clients, replays them to compute expected state, and compares against actual state. If they diverge, something went wrong, and you&#x27;ll know exactly which operations succeeded. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;blob&#x2F;4ed057a&#x2F;foundationdb-simulation&#x2F;examples&#x2F;atomic&#x2F;lib.rs&quot;&gt;Rust atomic workload example&lt;&#x2F;a&gt; for a complete implementation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-determinism-rules&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-determinism-rules&quot; aria-label=&quot;Anchor link for: the-determinism-rules&quot;&gt;üîó&lt;&#x2F;a&gt;The Determinism Rules&lt;&#x2F;h2&gt;
&lt;p&gt;FDB&#x27;s simulation is deterministic. Same seed, same execution path, same bugs. This is the superpower that lets you reproduce failures. But determinism is fragile. Break it, and you lose reproducibility. Five rules to remember:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;BTreeMap, not HashMap&lt;&#x2F;strong&gt;: HashMap iteration order is non-deterministic&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;context.rnd(), not rand::random()&lt;&#x2F;strong&gt;: All randomness must come from the seeded PRNG&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;context.now(), not SystemTime::now()&lt;&#x2F;strong&gt;: Use simulation time, not wall clock&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;db.run(), not manual retry loops&lt;&#x2F;strong&gt;: The framework handles retries and &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; correctly&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No tokio::spawn()&lt;&#x2F;strong&gt;: The simulation runs on a custom executor, spawning breaks it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If you take nothing else from this post, memorize these. Break any of them and your failures become unreproducible. You&#x27;ll see a bug once and never find it again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;architecture-the-three-crate-pattern&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#architecture-the-three-crate-pattern&quot; aria-label=&quot;Anchor link for: architecture-the-three-crate-pattern&quot;&gt;üîó&lt;&#x2F;a&gt;Architecture: The Three-Crate Pattern&lt;&#x2F;h2&gt;
&lt;p&gt;Real production systems use tokio, gRPC, REST frameworks, all of which break simulation determinism. You can&#x27;t just drop your production binary into the simulator. The solution is separating your FDB operations into a simulation-friendly crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;my-project&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;‚îú‚îÄ‚îÄ my-fdb-service&#x2F;      # Core FDB operations - NO tokio
&lt;&#x2F;span&gt;&lt;span&gt;‚îú‚îÄ‚îÄ my-grpc-server&#x2F;      # Production layer (tokio + tonic)
&lt;&#x2F;span&gt;&lt;span&gt;‚îî‚îÄ‚îÄ my-fdb-workloads&#x2F;    # Simulation tests
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The service crate contains pure FDB transaction logic with no async runtime dependency. The server crate wraps it for production. The workloads crate tests the actual service logic under simulation chaos. This lets you test your real production code, not a reimplementation that might have different bugs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;common-pitfalls&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#common-pitfalls&quot; aria-label=&quot;Anchor link for: common-pitfalls&quot;&gt;üîó&lt;&#x2F;a&gt;Common Pitfalls&lt;&#x2F;h2&gt;
&lt;p&gt;Beyond the determinism rules above, these mistakes will bite you:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Running setup or check on all clients.&lt;&#x2F;strong&gt; The framework runs multiple clients concurrently. If every client initializes data in &lt;code&gt;setup()&lt;&#x2F;code&gt;, you get duplicate initialization. If every client validates in &lt;code&gt;check()&lt;&#x2F;code&gt;, you get inconsistent results. Use &lt;code&gt;if self.client_id == 0&lt;&#x2F;code&gt; to ensure only one client handles initialization and validation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Forgetting maybe_committed.&lt;&#x2F;strong&gt; The &lt;code&gt;db.run()&lt;&#x2F;code&gt; closure receives a &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; flag indicating the previous attempt might have succeeded. If you&#x27;re doing non-idempotent operations like atomic increments, you need either truly idempotent transactions or &lt;a href=&quot;&#x2F;posts&#x2F;automatic-txn-fdb-730&#x2F;&quot;&gt;automatic idempotency&lt;&#x2F;a&gt; in FDB 7.3+. Ignoring this flag means your workload might count operations twice.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Storing SimDatabase between phases.&lt;&#x2F;strong&gt; Each phase (&lt;code&gt;setup&lt;&#x2F;code&gt;, &lt;code&gt;start&lt;&#x2F;code&gt;, &lt;code&gt;check&lt;&#x2F;code&gt;) gets a fresh database reference. Storing the old one leads to undefined behavior. Always use the &lt;code&gt;db&lt;&#x2F;code&gt; parameter passed to each method.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Wrapping FdbError in custom error types.&lt;&#x2F;strong&gt; The &lt;code&gt;db.run()&lt;&#x2F;code&gt; retry mechanism checks if errors are retryable via &lt;code&gt;FdbError::is_retryable()&lt;&#x2F;code&gt;. If you wrap &lt;code&gt;FdbError&lt;&#x2F;code&gt; in your own error type (like &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt; or a custom enum), the retry logic can&#x27;t see the underlying error and won&#x27;t retry. Keep &lt;code&gt;FdbError&lt;&#x2F;code&gt; unwrapped in your transaction closures, or ensure your error type preserves retryability information.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Assuming setup is safe from failures.&lt;&#x2F;strong&gt; BUGGIFY is disabled during &lt;code&gt;setup()&lt;&#x2F;code&gt;, so you might think transactions can&#x27;t fail. But simulation randomizes FDB knobs, which can still cause transaction failures. Always use &lt;code&gt;db.run()&lt;&#x2F;code&gt; with retry logic even in setup, or wrap your setup in a retry loop.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-real-value&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-real-value&quot; aria-label=&quot;Anchor link for: the-real-value&quot;&gt;üîó&lt;&#x2F;a&gt;The Real Value&lt;&#x2F;h2&gt;
&lt;p&gt;That &lt;code&gt;commit_unknown_result&lt;&#x2F;code&gt; edge case appeared on our first simulation seed. In production, we&#x27;d still be hunting it months later. 30 minutes of simulation covers what would take 24 hours of chaos testing. But the real value of simulation testing isn&#x27;t just finding bugs, it&#x27;s &lt;strong&gt;forcing you to think about correctness.&lt;&#x2F;strong&gt; When you design a workload, you&#x27;re forced to ask: &quot;What happens when this retries during a partition?&quot; &quot;How do I verify correctness when transactions can commit in any order?&quot; &quot;What invariants must hold no matter what chaos occurs?&quot; Designing for chaos becomes natural. And if it survives simulation, it survives production.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with questions or to share your simulation workloads. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>From Arc to Box: One Deref Bound to Rule Them All</title>
        <published>2025-10-02T00:00:00+00:00</published>
        <updated>2025-10-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/from-arc-to-box-one-deref-bound/"/>
        <id>https://pierrezemb.fr/posts/from-arc-to-box-one-deref-bound/</id>
        
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <category term="programming" schema="https://pierrezemb.fr/tags/" label="programming"/>
        <category term="metaprogramming" schema="https://pierrezemb.fr/tags/" label="metaprogramming"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/from-arc-to-box-one-deref-bound/">&lt;p&gt;While working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&quot;&gt;FoundationDB-rs&lt;&#x2F;a&gt;, I hit a design problem that seemed like it would require complex trait gymnastics. I had two transaction types with identical APIs but different ownership semantics, and I needed functions to accept both. The solution turned out to be embarrassingly simple. It was already implemented.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-problem-two-transaction-types-one-api&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-problem-two-transaction-types-one-api&quot; aria-label=&quot;Anchor link for: the-problem-two-transaction-types-one-api&quot;&gt;üîó&lt;&#x2F;a&gt;The Problem: Two Transaction Types, One API&lt;&#x2F;h2&gt;
&lt;p&gt;FoundationDB-rs has two transaction types that do exactly the same thing but with different ownership models:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Transaction {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inner&lt;&#x2F;span&gt;&lt;span&gt;: NonNull&amp;lt;fdb_sys::FDBTransaction&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metrics&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;TransactionMetrics&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;RetryableTransaction {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inner&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;Transaction&amp;gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Arc needed for retry loop ownership
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Why two types?&lt;&#x2F;strong&gt; FoundationDB requires retry loops for handling conflicts and retriable errors. The &lt;code&gt;Transaction&lt;&#x2F;code&gt; is perfect when you&#x27;re managing retries manually or doing single-shot operations. The &lt;code&gt;RetryableTransaction&lt;&#x2F;code&gt; wraps it in an &lt;code&gt;Arc&lt;&#x2F;code&gt; so the automatic retry machinery in &lt;code&gt;Database::run()&lt;&#x2F;code&gt; can clone references across async boundaries and exponential backoff delays.&lt;&#x2F;p&gt;
&lt;p&gt;The challenge: users need to write code that works with both. Real FoundationDB applications mix both patterns depending on the use case.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-obvious-solutions-didn-t-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-obvious-solutions-didn-t-work&quot; aria-label=&quot;Anchor link for: the-obvious-solutions-didn-t-work&quot;&gt;üîó&lt;&#x2F;a&gt;The Obvious Solutions Didn&#x27;t Work&lt;&#x2F;h2&gt;
&lt;p&gt;My first instinct was creating a trait. But FoundationDB-rs operates directly on raw C pointers (&lt;code&gt;NonNull&amp;lt;fdb_sys::FDBTransaction&amp;gt;&lt;&#x2F;code&gt;) with custom &lt;code&gt;Future&lt;&#x2F;code&gt; implementations that handle FFI complexity and error mapping. Writing a trait with async methods that return these custom futures means associated types, lifetime bounds, and complex error handling. The resulting trait becomes painful to use and understand.&lt;&#x2F;p&gt;
&lt;p&gt;I considered an enum wrapper:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;AnyTransaction&amp;lt;&amp;#39;a&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Regular(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; Transaction),
&lt;&#x2F;span&gt;&lt;span&gt;    Retryable(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; RetryableTransaction),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But this felt wrong. Users would need to match everywhere, and it adds runtime overhead for what should be a compile-time decision. Plus it doesn&#x27;t feel natural to use.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-accidental-solution&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-accidental-solution&quot; aria-label=&quot;Anchor link for: the-accidental-solution&quot;&gt;üîó&lt;&#x2F;a&gt;The Accidental Solution&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;RetryableTransaction&lt;&#x2F;code&gt; already had this implementation for convenience:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Deref &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;RetryableTransaction {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Target = Transaction;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;deref&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &amp;amp;Transaction {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.inner.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;deref&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;d added this so users could call transaction methods directly on &lt;code&gt;RetryableTransaction&lt;&#x2F;code&gt; instances. But this &lt;strong&gt;accidentally solved the entire design problem.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Functions can accept both types through a simple generic bound:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;perform_operations&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tx&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;T) -&amp;gt; FdbResult&amp;lt;()&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    T: Deref&amp;lt;Target = Transaction&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;).await?;
&lt;&#x2F;span&gt;&lt;span&gt;    tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_range&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now the same function works seamlessly with both transaction types:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Direct transaction usage
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; tx = db.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;create_transaction&lt;&#x2F;span&gt;&lt;span&gt;()?;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;perform_operations&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;tx).await?;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Automatic retry loop usage
&lt;&#x2F;span&gt;&lt;span&gt;db.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rtx&lt;&#x2F;span&gt;&lt;span&gt;| async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;perform_operations&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;rtx).await?;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Same function, no changes needed!
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}).await?;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The compiler handles everything through deref coercion. All methods of &lt;code&gt;Transaction&lt;&#x2F;code&gt; remain directly accessible on both types, and there&#x27;s zero runtime overhead.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-pattern-arc-deref-universal-apis&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-pattern-arc-deref-universal-apis&quot; aria-label=&quot;Anchor link for: the-pattern-arc-deref-universal-apis&quot;&gt;üîó&lt;&#x2F;a&gt;The Pattern: Arc&lt;T&gt; + Deref = Universal APIs&lt;&#x2F;h2&gt;
&lt;p&gt;This pattern works whenever you have a type &lt;code&gt;T&lt;&#x2F;code&gt; and a wrapper containing &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; (or &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, etc.). As long as the wrapper implements &lt;code&gt;Deref&amp;lt;Target = T&amp;gt;&lt;&#x2F;code&gt;, you can write generic functions that accept both:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Any function with this signature accepts:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; - &amp;amp;T directly  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; - &amp;amp;WrapperType where WrapperType: Deref&amp;lt;Target = T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; - &amp;amp;Arc&amp;lt;T&amp;gt;, &amp;amp;Box&amp;lt;T&amp;gt;, &amp;amp;Rc&amp;lt;T&amp;gt; (stdlib types already implement Deref)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;use_any_version&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;D&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;D)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where 
&lt;&#x2F;span&gt;&lt;span&gt;    D: Deref&amp;lt;Target = T&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    val.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;some_method&lt;&#x2F;span&gt;&lt;span&gt;();  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; All methods of T available through deref coercion
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key insight: when you&#x27;re designing APIs that need to work with both &lt;code&gt;T&lt;&#x2F;code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, don&#x27;t reach for traits or enums. The standard library already solved this. &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; implements &lt;code&gt;Deref&amp;lt;Target = T&amp;gt;&lt;&#x2F;code&gt;, and your custom wrapper types should do the same.&lt;&#x2F;p&gt;
&lt;p&gt;Once you implement &lt;code&gt;Deref&lt;&#x2F;code&gt;, any function that accepts &lt;code&gt;&amp;amp;D where D: Deref&amp;lt;Target = T&amp;gt;&lt;&#x2F;code&gt; automatically works with your owned type, your wrapper type, and any smart pointer containing your type. The compiler handles everything through deref coercion, and you get zero-cost abstraction that feels completely natural to use.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your experiences with Deref patterns in Rust. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Thank You, DataFusion: Queries in Rust, Without the Pain</title>
        <published>2025-06-04T00:00:00+00:00</published>
        <updated>2025-06-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/thank-you-datafusion/"/>
        <id>https://pierrezemb.fr/posts/thank-you-datafusion/</id>
        
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="datafusion" schema="https://pierrezemb.fr/tags/" label="datafusion"/>
        <category term="sql" schema="https://pierrezemb.fr/tags/" label="sql"/>
        <category term="query-engine" schema="https://pierrezemb.fr/tags/" label="query-engine"/>
        <category term="databases" schema="https://pierrezemb.fr/tags/" label="databases"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/thank-you-datafusion/">&lt;h2 id=&quot;that-yatta-moment-rebooted&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#that-yatta-moment-rebooted&quot; aria-label=&quot;Anchor link for: that-yatta-moment-rebooted&quot;&gt;üîó&lt;&#x2F;a&gt;That ‚ÄúYATTA!‚Äù Moment, Rebooted&lt;&#x2F;h2&gt;
&lt;p&gt;We just merged at work our first successful data retrieval using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&quot;&gt;DataFusion&lt;&#x2F;a&gt; ‚Äî a real SQL query, over real data, flowing through a system we built. And I‚Äôll be honest: I haven‚Äôt had a ‚ÄúYATTA!‚Äù moment like this in years. This wasn&#x27;t just a feature shipped; it felt like unlocking a new superpower for our entire system, a complex vision finally materializing.&lt;&#x2F;p&gt;
&lt;p&gt;Not a silent nod. Not ‚Äúhuh, that works.‚Äù A &lt;em&gt;real&lt;&#x2F;em&gt;, physical, joyful reaction. The kind that makes you want to run a lap around the office (or, in my remote-first case, the living room).&lt;&#x2F;p&gt;
&lt;p&gt;Because plugging a query engine into your software isn‚Äôt supposed to feel this smooth. It&#x27;s usually a battle. But this one did. This one felt like an invitation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;you-don-t-just-add-a-query-engine&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#you-don-t-just-add-a-query-engine&quot; aria-label=&quot;Anchor link for: you-don-t-just-add-a-query-engine&quot;&gt;üîó&lt;&#x2F;a&gt;You Don‚Äôt Just Add a Query Engine&lt;&#x2F;h2&gt;
&lt;p&gt;Adding a query engine to a codebase isn‚Äôt something you do lightly. It‚Äôs a foundational piece of infrastructure, the kind of decision that usually ends in regret, or at least a &lt;em&gt;lot&lt;&#x2F;em&gt; of rewriting. Most engines assume they own the world: they want to dictate your storage, your execution model, your schema, your optimizer, often forcing you to contort your application around their idiosyncrasies. It&#x27;s a path often paved with impedance mismatches, performance bottlenecks, and the haunting feeling that you‚Äôve just bolted an opinionated, unyielding black box onto your carefully crafted system.&lt;&#x2F;p&gt;
&lt;p&gt;But then there‚Äôs DataFusion. A SQL engine written in Rust, and ‚Äî against all odds ‚Äî one you can actually &lt;em&gt;use&lt;&#x2F;em&gt;. Drop-in? Not quite. But close enough to be kind of magical, offering a set of powerful, composable tools rather than a rigid framework.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;i-ve-been-watching-from-day-one&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#i-ve-been-watching-from-day-one&quot; aria-label=&quot;Anchor link for: i-ve-been-watching-from-day-one&quot;&gt;üîó&lt;&#x2F;a&gt;I‚Äôve Been Watching From Day One&lt;&#x2F;h2&gt;
&lt;p&gt;I‚Äôve been following DataFusion since it was a weekend project. I still remember the early blog posts, the prototypes, the potential. And more importantly, I read &lt;a href=&quot;https:&#x2F;&#x2F;andygrove.io&#x2F;how-query-engines-work&#x2F;&quot;&gt;Andy Grove‚Äôs book &lt;em&gt;How Query Engines Work&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. That book unlocked it for me.&lt;&#x2F;p&gt;
&lt;p&gt;It demystified concepts like logical plans, physical plans, and execution trees ‚Äî enough to give me the confidence to experiment. I first played with Apache Calcite, then circled back to DataFusion. Eventually, I contributed a small example: a custom &lt;code&gt;TableProvider&lt;&#x2F;code&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;issues&#x2F;1864&quot;&gt;added to DataFusion in this issue&lt;&#x2F;a&gt; to demonstrate how to integrate custom datasources.&lt;&#x2F;p&gt;
&lt;p&gt;And then... it only took me &lt;strong&gt;three years&lt;&#x2F;strong&gt; to actually write the code that &lt;em&gt;used&lt;&#x2F;em&gt; it. Why so long? Well, let&#x27;s just say a gazillion other things, the never-ending sagas of on-call, and a &lt;a href=&quot;&#x2F;posts&#x2F;back-engineering&quot;&gt;brief-but-eventful detour into management&lt;&#x2F;a&gt; kept my dance card impressively full. But hey, it still felt amazing when it finally clicked.&lt;&#x2F;p&gt;
&lt;p&gt;More recently, I was genuinely happy to see that &lt;strong&gt;Andrew Lamb&lt;&#x2F;strong&gt; co-authored an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;issues&#x2F;6782&quot;&gt;academic paper describing DataFusion‚Äôs architecture&lt;&#x2F;a&gt;. There‚Äôs something really validating about seeing a project you‚Äôve followed for years get formalized in research ‚Äî it‚Äôs a sign that the internals are solid and the ideas are worth sharing. And they are.&lt;&#x2F;p&gt;
&lt;p&gt;That moment was big. Because here was a Rust-native query engine where I could plug in &lt;em&gt;my own data&lt;&#x2F;em&gt;, and get &lt;em&gt;real queries&lt;&#x2F;em&gt; back. No layers of JVM glue, no corroded abstractions. Just composable, hackable Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;modular-composable-respectful&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#modular-composable-respectful&quot; aria-label=&quot;Anchor link for: modular-composable-respectful&quot;&gt;üîó&lt;&#x2F;a&gt;Modular, Composable, Respectful&lt;&#x2F;h2&gt;
&lt;p&gt;What I love about DataFusion is that it doesn‚Äôt try to control your application. It‚Äôs a query engine that knows it‚Äôs a library ‚Äî not a database.&lt;&#x2F;p&gt;
&lt;p&gt;It lets you:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Plug in your own data sources&lt;&#x2F;li&gt;
&lt;li&gt;Register logical tables dynamically&lt;&#x2F;li&gt;
&lt;li&gt;Push down filters, projections, even partitions&lt;&#x2F;li&gt;
&lt;li&gt;Swap in or extend physical execution nodes&lt;&#x2F;li&gt;
&lt;li&gt;Keep your own runtime, threading, and lifecycle&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;And all that without feeling like you‚Äôre stepping into ‚Äúinternal‚Äù code. It‚Äôs all open, cleanly layered, and welcoming.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;my-goal-join-indexes-without-going-insane&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#my-goal-join-indexes-without-going-insane&quot; aria-label=&quot;Anchor link for: my-goal-join-indexes-without-going-insane&quot;&gt;üîó&lt;&#x2F;a&gt;My Goal: Join Indexes Without Going Insane&lt;&#x2F;h2&gt;
&lt;p&gt;From the beginning, my goal was never to just scan data ‚Äî it was to &lt;strong&gt;query it properly&lt;&#x2F;strong&gt;, with indexes, joins, and all the things a real engine should do. I never had any intention of writing a join execution engine myself. That‚Äôs not the kind of wheel I want to reinvent.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s no secret that at work, we&#x27;re building a system on top of FoundationDB that draws inspiration from Apple&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;foundationdb.github.io&#x2F;fdb-record-layer&#x2F;&quot;&gt;FDB Record Layer&lt;&#x2F;a&gt; (you can learn more about its concepts in &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SvoUHHM9IKU&quot;&gt;this talk&lt;&#x2F;a&gt;). We offer &lt;a href=&quot;https:&#x2F;&#x2F;foundationdb.github.io&#x2F;fdb-record-layer&#x2F;GettingStarted.html&quot;&gt;a similar programmatic API for constructing queries&lt;&#x2F;a&gt;, which naturally leads to similar requirements. For example, developers need to express sophisticated data retrieval logic, much like this FDB Record Layer example for querying orders:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;RecordQuery&lt;&#x2F;span&gt;&lt;span&gt; query = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;RecordQuery&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newBuilder&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;setRecordType&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Order&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;setFilter&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Query&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Query&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;field&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;price&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lessThan&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Query&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;field&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;flower&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;matches&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Query&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;field&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;equalsValue&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;FlowerType&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;ROSE&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;()))))
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;build&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The challenge then becomes translating such programmatic queries into efficient, index-backed scans and, crucially, leveraging a robust engine for complex operations like joins‚Äîwithout rebuilding that engine from scratch.&lt;&#x2F;p&gt;
&lt;p&gt;What I wanted was the ability to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Fetch rows efficiently through custom index-backed scans&lt;&#x2F;li&gt;
&lt;li&gt;Join them using &lt;code&gt;HashJoinExec&lt;&#x2F;code&gt; or &lt;code&gt;MergeJoinExec&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Let the planner and execution engine figure out the hard parts&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This vision is what spurred me to start working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;datafusion-contrib&#x2F;datafusion-index-provider&quot;&gt;&lt;code&gt;datafusion-index-provider&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, a library hosted in the &lt;code&gt;datafusion-contrib&lt;&#x2F;code&gt; GitHub organization ‚Äî part of the growing ecosystem around DataFusion. At the time of writing, I‚Äôve built a PoC ‚Äî you can find it &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PierreZ&#x2F;datafusion-index-provider&#x2F;tree&#x2F;init-v2&quot;&gt;on this branch&lt;&#x2F;a&gt; ‚Äî and I‚Äôm integrating it into our internal stack before opening a proper PR upstream.&lt;&#x2F;p&gt;
&lt;p&gt;The architecture makes it feel possible. The abstractions are ready. And I still don‚Äôt have to write a join engine. Victory.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-joy-of-real-libraries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-joy-of-real-libraries&quot; aria-label=&quot;Anchor link for: the-joy-of-real-libraries&quot;&gt;üîó&lt;&#x2F;a&gt;The Joy of Real Libraries&lt;&#x2F;h2&gt;
&lt;p&gt;There‚Äôs a special joy in finding a library that &lt;em&gt;slots in&lt;&#x2F;em&gt; ‚Äî that doesn‚Äôt just solve a problem, but fits the shape of your system. DataFusion was that for me.&lt;&#x2F;p&gt;
&lt;p&gt;It didn‚Äôt just let me query data; it gave me a better way to think about the data I already had, and how I wanted to work with it. Instead of manually stitching together filters and projections, I could describe my intent, and let the engine handle the rest.&lt;&#x2F;p&gt;
&lt;p&gt;What‚Äôs even more exciting is that this isn‚Äôt happening in a vacuum.&lt;&#x2F;p&gt;
&lt;p&gt;We‚Äôre seeing a quiet shift in how query engines are built and used. Projects like &lt;a href=&quot;https:&#x2F;&#x2F;duckdb.org&#x2F;&quot;&gt;DuckDB&lt;&#x2F;a&gt; have shown just how powerful it is to have &lt;strong&gt;SQL as a library&lt;&#x2F;strong&gt;, not a service. No server to deploy. No socket to connect to. Just an API, embedded right in your code.&lt;&#x2F;p&gt;
&lt;p&gt;DataFusion follows that same philosophy ‚Äî Rust-native, embeddable, and unapologetically library-first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;to-the-datafusion-team-thank-you&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#to-the-datafusion-team-thank-you&quot; aria-label=&quot;Anchor link for: to-the-datafusion-team-thank-you&quot;&gt;üîó&lt;&#x2F;a&gt;To the DataFusion Team: Thank You&lt;&#x2F;h2&gt;
&lt;p&gt;To Andy Grove, to all the contributors, to everyone filing issues and refining abstractions: thank you. Your work is enabling a new generation of Rust systems to think like databases ‚Äî without becoming one.&lt;&#x2F;p&gt;
&lt;p&gt;I don‚Äôt know if you realize how rare that is. I just know it changed what I thought was possible in my software.&lt;&#x2F;p&gt;
&lt;p&gt;And I‚Äôm having a lot more fun because of it.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your experiences with DataFusion. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Unlocking Tokio&#x27;s Hidden Gems: Determinism, Paused Time, and Local Execution</title>
        <published>2025-05-18T18:13:02+02:00</published>
        <updated>2025-05-18T18:13:02+02:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/tokio-hidden-gems/"/>
        <id>https://pierrezemb.fr/posts/tokio-hidden-gems/</id>
        
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="tokio" schema="https://pierrezemb.fr/tags/" label="tokio"/>
        <category term="async" schema="https://pierrezemb.fr/tags/" label="async"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="concurrency" schema="https://pierrezemb.fr/tags/" label="concurrency"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/tokio-hidden-gems/">&lt;p&gt;Tokio is the powerhouse of asynchronous Rust, celebrated for its blazing speed and robust concurrency primitives. Many of us interact with its core components daily‚Äî&lt;code&gt;spawn&lt;&#x2F;code&gt;, &lt;code&gt;select!&lt;&#x2F;code&gt;, &lt;code&gt;async fn&lt;&#x2F;code&gt;, and the rich ecosystem of I&#x2F;O utilities. But beyond these well-trodden paths lie some incredibly potent, albeit less-publicized, features that can dramatically elevate your testing strategies, offer more nuanced task management, and grant you surgical control over your runtime&#x27;s execution.&lt;&#x2F;p&gt;
&lt;p&gt;Today, let&#x27;s pull back the curtain on a few of these invaluable tools: current-thread runtimes for embracing single-threaded flexibility with &lt;code&gt;!Send&lt;&#x2F;code&gt; types, seeded runtimes for taming non-determinism, and the paused clock for mastering time in your tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;effortless-send-futures-with-current-thread-runtimes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#effortless-send-futures-with-current-thread-runtimes&quot; aria-label=&quot;Anchor link for: effortless-send-futures-with-current-thread-runtimes&quot;&gt;üîó&lt;&#x2F;a&gt;Effortless &lt;code&gt;!Send&lt;&#x2F;code&gt; Futures with Current-Thread Runtimes&lt;&#x2F;h2&gt;
&lt;p&gt;While Tokio&#x27;s multi-threaded scheduler is a marvel for CPU-bound and parallel I&#x2F;O tasks, there are scenarios where a single-threaded execution model is simpler or even necessary. This is particularly true when dealing with types that are not &lt;code&gt;Send&lt;&#x2F;code&gt; (i.e., cannot be safely transferred across threads), such as &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, or when you want to avoid the overhead and complexity of synchronization primitives like &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; for state shared only within a single thread of execution.&lt;&#x2F;p&gt;
&lt;p&gt;Tokio&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.new_current_thread&quot;&gt;&lt;code&gt;Builder::new_current_thread()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; followed by &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.build_local&quot;&gt;&lt;code&gt;build_local()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (part of the same &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html&quot;&gt;&lt;code&gt;Builder&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; API) provides a streamlined way to create a runtime that executes tasks on the thread that created it. This setup inherently supports spawning &lt;code&gt;!Send&lt;&#x2F;code&gt; futures using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html&quot;&gt;&lt;code&gt;tokio::task::spawn_local&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; without needing to manually manage a &lt;code&gt;LocalSet&lt;&#x2F;code&gt; for basic cases. This approach aligns well with ongoing discussions in the Tokio community aimed at simplifying &lt;code&gt;!Send&lt;&#x2F;code&gt; task management.&lt;&#x2F;p&gt;
&lt;p&gt;This &lt;code&gt;build_local()&lt;&#x2F;code&gt; method not only simplifies handling &lt;code&gt;!Send&lt;&#x2F;code&gt; types today but also reflects the direction Tokio is heading. The Tokio team is exploring ways to make this even more integrated and ergonomic through a proposed &lt;strong&gt;&lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; type (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;issues&#x2F;6739&quot;&gt;#6739&lt;&#x2F;a&gt;). The vision for &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt; is a runtime that is inherently &lt;code&gt;!Send&lt;&#x2F;code&gt; (making &lt;code&gt;!Send&lt;&#x2F;code&gt; task management seamless within its context), where &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt; and &lt;code&gt;tokio::task::spawn_local&lt;&#x2F;code&gt; would effectively behave identically.&lt;&#x2F;p&gt;
&lt;p&gt;This proposed enhancement is linked to a discussion about potentially deprecating the existing &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;struct.LocalSet.html&quot;&gt;&lt;code&gt;tokio::task::LocalSet&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;issues&#x2F;6741&quot;&gt;#6741&lt;&#x2F;a&gt;). While &lt;code&gt;LocalSet&lt;&#x2F;code&gt; currently offers fine-grained control for running &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks (e.g., within specific parts of larger, multi-threaded applications), it comes with complexities, performance overhead, and integration challenges that &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt; aims to resolve.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;So, what&#x27;s the takeaway for you?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;For most scenarios requiring &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks on a single thread&lt;&#x2F;strong&gt; (like entire applications, test suites, or dedicated utility threads): Using &lt;code&gt;Builder::new_current_thread().build_local()&lt;&#x2F;code&gt; is the recommended, simpler, and more future-proof path. It embodies the principles of the proposed &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;If you need to embed &lt;code&gt;!Send&lt;&#x2F;code&gt; task execution within a specific scope of a larger, multi-threaded application&lt;&#x2F;strong&gt;: &lt;code&gt;LocalSet&lt;&#x2F;code&gt; is the current tool. However, be mindful of its potential deprecation and associated complexities. For new projects, evaluate if a dedicated thread using a &lt;code&gt;build_local()&lt;&#x2F;code&gt; runtime (or a future &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;) might offer a cleaner solution.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Essentially, Tokio is moving towards making single-threaded &lt;code&gt;!Send&lt;&#x2F;code&gt; execution more straightforward and deeply integrated. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.build_local&quot;&gt;&lt;code&gt;build_local()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is a current gem that aligns you with this forward-looking approach.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s how you typically set one up (the &lt;code&gt;build_local()&lt;&#x2F;code&gt; way):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::runtime::Builder;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; rt = Builder::new_current_thread()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enable_all&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Enable I&#x2F;O, time, etc.
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_local&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Default::default()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Builds a runtime on the current thread
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The runtime itself is the &amp;#39;LocalSet&amp;#39; in this context
&lt;&#x2F;span&gt;&lt;span&gt;    rt.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(async {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Spawn !Send futures here using tokio::task::spawn_local(...)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; For example:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rc_value = std::rc::Rc::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::task::spawn_local(async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;RC value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, *rc_value);
&lt;&#x2F;span&gt;&lt;span&gt;        }).await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Running !Send futures on a current-thread runtime!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach simplifies designs where tasks don&#x27;t need to cross thread boundaries, allowing for more straightforward state management.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;taming-non-determinism-seeded-runtimes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#taming-non-determinism-seeded-runtimes&quot; aria-label=&quot;Anchor link for: taming-non-determinism-seeded-runtimes&quot;&gt;üîó&lt;&#x2F;a&gt;Taming Non-Determinism: Seeded Runtimes&lt;&#x2F;h2&gt;
&lt;p&gt;One of the challenges in testing concurrent systems is non-determinism. When multiple futures are ready to make progress simultaneously, such as in a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;macro.select.html&quot;&gt;&lt;code&gt;tokio::select!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro, the order in which they are polled can vary between runs. This can make reproducing and debugging race conditions or specific interleavings tricky.&lt;&#x2F;p&gt;
&lt;p&gt;Tokio offers a solution: &lt;strong&gt;seeded runtimes&lt;&#x2F;strong&gt;. By providing a specific &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.rng_seed&quot;&gt;&lt;code&gt;RngSeed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when building the runtime, you can make certain scheduler behaviors deterministic. This is particularly useful for &lt;code&gt;select!&lt;&#x2F;code&gt; statements involving multiple futures that become ready around the same time.&lt;&#x2F;p&gt;
&lt;p&gt;Consider this example, which demonstrates how a seed can influence which future &#x27;wins&#x27; a &lt;code&gt;select!&lt;&#x2F;code&gt; race:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::runtime::{Builder, RngSeed};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::time::{sleep, Duration};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Example function to show deterministic select!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;demo_deterministic_select&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Try changing this seed to see the select! behavior change (but consistently per seed).
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; seed = RngSeed::from_bytes(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my_fixed_seed_001&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; e.g., let seed = RngSeed::from_bytes(b&amp;quot;another_seed_002&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; rt = Builder::new_current_thread()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enable_time&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Pausing the clock is crucial here to ensure both tasks become ready 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; at the *exact same logical time* after we call `tokio::time::advance`.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This makes the seed&amp;#39;s role in tie-breaking very clear.
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;start_paused&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rng_seed&lt;&#x2F;span&gt;&lt;span&gt;(seed)     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Apply the seed for deterministic polling order
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_local&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Default::default())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Now, let&amp;#39;s run some tasks and see select! in action.
&lt;&#x2F;span&gt;&lt;span&gt;    rt.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(async {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task_a = async {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Task A finished.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Result from A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task_b = async {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Task B finished.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Result from B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Advance time so both sleeps complete and both tasks become ready.
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::time::advance(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; With the same seed, the select! macro will consistently pick the same
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; branch if both are ready. Change the seed to see if the other branch gets picked.
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::select! {
&lt;&#x2F;span&gt;&lt;span&gt;            res_a = task_a =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Select chose Task A, result: &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, res_a);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            res_b = task_b =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Select chose Task B, result: &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, res_b);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;demo_deterministic_select&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;mastering-time-paused-clock-and-auto-advancement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mastering-time-paused-clock-and-auto-advancement&quot; aria-label=&quot;Anchor link for: mastering-time-paused-clock-and-auto-advancement&quot;&gt;üîó&lt;&#x2F;a&gt;Mastering Time: Paused Clock and Auto-Advancement&lt;&#x2F;h2&gt;
&lt;p&gt;Testing time-dependent behavior (timeouts, retries, scheduled tasks) can be slow and flaky. Waiting for real seconds or minutes to pass during tests is inefficient. Tokio&#x27;s time facilities can be &lt;strong&gt;paused&lt;&#x2F;strong&gt; and &lt;strong&gt;manually advanced&lt;&#x2F;strong&gt;, giving you precise control over the flow of time within your tests.&lt;&#x2F;p&gt;
&lt;p&gt;When you initialize a runtime with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.start_paused&quot;&gt;&lt;code&gt;start_paused(true)&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, the runtime&#x27;s clock will not advance automatically based on wall-clock time. Instead, you use &lt;code&gt;tokio::time::advance(Duration)&lt;&#x2F;code&gt; to move time forward explicitly.&lt;&#x2F;p&gt;
&lt;p&gt;What&#x27;s particularly neat is Tokio&#x27;s &lt;strong&gt;auto-advance&lt;&#x2F;strong&gt; feature when the runtime is paused and idle. This works because Tokio&#x27;s runtime separates the &lt;strong&gt;executor&lt;&#x2F;strong&gt; (which polls your async code until it&#x27;s blocked) from the &lt;strong&gt;reactor&lt;&#x2F;strong&gt; (which wakes tasks based on I&#x2F;O or timer events). If all tasks are sleeping, the executor is idle. The reactor can then identify the next scheduled timer, allowing Tokio to automatically advance its clock to that point. This prevents tests from hanging indefinitely while still allowing for controlled time progression.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s your example illustrating this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::time::{Duration, Instant, sleep};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;auto_advance_kicks_in_when_idle_example&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start = Instant::now();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Sleep for 5 seconds. Since the runtime is paused, this would normally hang.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; However, if no other tasks are active, Tokio auto-advances time.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elapsed = start.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;elapsed&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This will be exactly 5 seconds (simulated time)
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(elapsed, Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elapsed (simulated): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, elapsed);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this scenario, &lt;code&gt;sleep(Duration::from_secs(5)).await&lt;&#x2F;code&gt; doesn&#x27;t cause your test to wait for 5 real seconds. Because the clock is paused and this &lt;code&gt;sleep&lt;&#x2F;code&gt; is the only pending timed event, Tokio advances its internal clock by 5 seconds, allowing the sleep to complete almost instantaneously in real time. This makes testing timeouts, scheduled events, and other time-sensitive logic fast and reliable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;üîó&lt;&#x2F;a&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Tokio offers more than just speed; it&#x27;s a powerful toolkit. Features like current-thread runtimes for &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks, seeded runtimes for deterministic tests, and a controllable clock for time-based logic help build robust and debuggable async Rust applications. These &#x27;hidden gems&#x27; allow you to confidently handle complex concurrency and testing. So, explore Tokio&#x27;s depth‚Äîthe right tool for your challenge might be closer than you think.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your thoughts. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Ensuring Safety in FoundationDB&#x27;s Rust Crate</title>
        <published>2025-02-11T00:00:00+01:00</published>
        <updated>2025-02-11T00:00:00+01:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/providing-safety-fdb-rs/"/>
        <id>https://pierrezemb.fr/posts/providing-safety-fdb-rs/</id>
        
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="database" schema="https://pierrezemb.fr/tags/" label="database"/>
        <category term="distributed" schema="https://pierrezemb.fr/tags/" label="distributed"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/providing-safety-fdb-rs/">&lt;p&gt;As we approach 5 million downloads of the &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;foundationdb&quot;&gt;FoundationDB Rust crate&lt;&#x2F;a&gt; (4,998,185 at the time of writing), I wanted to share some insights into how I ensure the safety of the crate. Being the primary maintainer of a database driver comes with responsibility, but I sleep well at night knowing that we have robust safety measures in place.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crate-overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#crate-overview&quot; aria-label=&quot;Anchor link for: crate-overview&quot;&gt;üîó&lt;&#x2F;a&gt;Crate Overview&lt;&#x2F;h2&gt;
&lt;p&gt;The Rust crate, &lt;code&gt;foundationdb-rs&lt;&#x2F;code&gt;, provides bindings to interact with FoundationDB&#x27;s C API (&lt;code&gt;libfdb&lt;&#x2F;code&gt;). It has around 13k lines of code and is used by companies (like Clever Cloud) and projects (such as Apache OpenDAL, SurrealDB). Having experienced numerous outages and issues with drivers and distributed systems, I understand the importance of safety. To ensure the safety of the crate, we need to focus on three layers:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The underlying client, &lt;code&gt;libfdb&lt;&#x2F;code&gt;,&lt;&#x2F;li&gt;
&lt;li&gt;The crate itself,&lt;&#x2F;li&gt;
&lt;li&gt;The code that uses the crate.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Let&#x27;s dig into each of these areas.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;libfdb-safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#libfdb-safety&quot; aria-label=&quot;Anchor link for: libfdb-safety&quot;&gt;üîó&lt;&#x2F;a&gt;libfdb Safety&lt;&#x2F;h2&gt;
&lt;p&gt;This is the simplest part. &lt;code&gt;libfdb&lt;&#x2F;code&gt;&#x27;s safety is guaranteed by FoundationDB&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;testing.html&quot;&gt;simulation framework&lt;&#x2F;a&gt;. Therefore, we can consider it safe.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;classic-testing-suite&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#classic-testing-suite&quot; aria-label=&quot;Anchor link for: classic-testing-suite&quot;&gt;üîó&lt;&#x2F;a&gt;Classic testing suite&lt;&#x2F;h3&gt;
&lt;p&gt;Since we are using a C library, we need to use FFI (Foreign Function Interface) and unsafe code blocks. With around 130 unsafe blocks, we must be extra careful when calling C code, ensuring all preconditions are met. Naturally, we conduct extensive testing, but most importantly, we run tests in high-variety environments:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;On multiple operating systems (Ubuntu, macOS)&lt;&#x2F;li&gt;
&lt;li&gt;On multiple FoundationDB versions (from FDB 6.1 to 7.3)&lt;&#x2F;li&gt;
&lt;li&gt;On multiple Rust compiler versions (Minimum Supported Rust Version or MSRV, stable, beta, nightly)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The most useful tests are run on the nightly Rust compiler, as we can catch &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;issues&#x2F;90&quot;&gt;new behaviors in the Rust compiler early&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;While these testing practices provide significant coverage, the most powerful tool we utilize comes from FoundationDB‚Äôs maintainers: the &lt;code&gt;BindingTester&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-bindingtester&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-bindingtester&quot; aria-label=&quot;Anchor link for: the-bindingtester&quot;&gt;üîó&lt;&#x2F;a&gt;The BindingTester&lt;&#x2F;h3&gt;
&lt;p&gt;FoundationDB is renowned for its &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;testing.html&quot;&gt;simulation and testing&lt;&#x2F;a&gt; frameworks. Bindings are no exception. They developed the BindingTester, a cross-language validation suite ensuring that all bindings behave correctly and consistently across different languages.&lt;&#x2F;p&gt;
&lt;p&gt;The BindingTester uses &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;main&#x2F;bindings&#x2F;bindingtester&#x2F;spec&#x2F;bindingApiTester.md&quot;&gt;a stack-based machine&lt;&#x2F;a&gt; to queue operations for FoundationDB. A program then reads the stack and performs the operations. These operations are run twice: once in the target environment and once against a reference implementation. Any differences are reported by the BindingTester.&lt;&#x2F;p&gt;
&lt;p&gt;It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;bindings&#x2F;bindingtester&#x2F;bindingtester.py --num-ops&lt;&#x2F;span&gt;&lt;span&gt; 1000&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --api-version&lt;&#x2F;span&gt;&lt;span&gt; 730&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --test-name&lt;&#x2F;span&gt;&lt;span&gt; api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --compare&lt;&#x2F;span&gt;&lt;span&gt; python rust
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Creating&lt;&#x2F;span&gt;&lt;span&gt; test at API version 730
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Generating&lt;&#x2F;span&gt;&lt;span&gt; api test at seed 3208032894 with 1000 op(s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt; 1 concurrent tester(s)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Inserting Rust tests
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Inserting&lt;&#x2F;span&gt;&lt;span&gt; test into database...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Running&lt;&#x2F;span&gt;&lt;span&gt; tester &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&#x2F;home&#x2F;runner&#x2F;work&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;target&#x2F;debug&#x2F;bindingtester test_spec 730&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Reading&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;workspace&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Reading&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;stack&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Inserting Python tests
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Inserting&lt;&#x2F;span&gt;&lt;span&gt; test into database...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Running&lt;&#x2F;span&gt;&lt;span&gt; tester &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;python &#x2F;home&#x2F;runner&#x2F;work&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;target&#x2F;foundationdb_build&#x2F;foundationdb&#x2F;bindings&#x2F;bindingtester&#x2F;..&#x2F;python&#x2F;tests&#x2F;tester.py test_spec 730&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Reading&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;workspace&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Reading&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;stack&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Comparing the results
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Comparing&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;workspace&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Comparing&lt;&#x2F;span&gt;&lt;span&gt; results from &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;tester_output&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;stack&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Test&lt;&#x2F;span&gt;&lt;span&gt; with seed 3208032894 and concurrency 1 had 0 incorrect result(s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt; 0 error(s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;at&lt;&#x2F;span&gt;&lt;span&gt; API version 730
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Completed&lt;&#x2F;span&gt;&lt;span&gt; api test with random seed 3208032894 and 1000 operations
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The great advantage of this method is that the tests are seeded, meaning the operations are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;randomly selected to cover all binding usages,&lt;&#x2F;li&gt;
&lt;li&gt;deterministic, so a failing seed can be replayed locally.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Combined with code coverage, this gives us a good idea of what has been tested (though code coverage may vary).&lt;&#x2F;p&gt;
&lt;p&gt;We run the &lt;code&gt;BindingTester&lt;&#x2F;code&gt; &lt;strong&gt;every hour&lt;&#x2F;strong&gt; on our GitHub actions, amounting to &lt;strong&gt;around 219 days of continuous testing each month&lt;&#x2F;strong&gt; (316,335 minutes of correctness last month according to Github).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;user-safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#user-safety&quot; aria-label=&quot;Anchor link for: user-safety&quot;&gt;üîó&lt;&#x2F;a&gt;User Safety&lt;&#x2F;h2&gt;
&lt;p&gt;Thanks to &lt;code&gt;libfdb&lt;&#x2F;code&gt; and the &lt;code&gt;BindingTester&lt;&#x2F;code&gt;, we can ensure that the library is quite safe. But what about the user&#x27;s code? How can we help users ensure their code can handle all of FoundationDB&#x27;s caveats, such as &lt;a href=&quot;&#x2F;posts&#x2F;automatic-txn-fdb-730&#x2F;#transactions-with-unknown-results&quot;&gt;commit_unknown_result&lt;&#x2F;a&gt;? We added a great feature: the ability to include Rust code &lt;strong&gt;within FDB&#x27;s simulation framework&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can implement an Rust workload with the following Trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;RustWorkload {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;setup&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: SimDatabase, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;done&lt;&#x2F;span&gt;&lt;span&gt;: Promise);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: SimDatabase, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;done&lt;&#x2F;span&gt;&lt;span&gt;: Promise);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;check&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: SimDatabase, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;done&lt;&#x2F;span&gt;&lt;span&gt;: Promise);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_metrics&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Vec&amp;lt;Metric&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_check_timeout&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which can be runned inside the simulation while injecting some faults:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fdbserver -r&lt;&#x2F;span&gt;&lt;span&gt; simulation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; &#x2F;root&#x2F;atomic.toml&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -b&lt;&#x2F;span&gt;&lt;span&gt; on&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --trace-format&lt;&#x2F;span&gt;&lt;span&gt; json
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Choosing a random seed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Random&lt;&#x2F;span&gt;&lt;span&gt; seed is 394378360...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Then, everything is derived from the seed, including:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# * cluster topology,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# * cluster configuration,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# * timing to inject faults,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# * operations to run
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# * ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Datacenter&lt;&#x2F;span&gt;&lt;span&gt; 0: 3&#x2F;12 machines, 1&#x2F;1 coordinators
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Datacenter&lt;&#x2F;span&gt;&lt;span&gt; 1: 3&#x2F;12 machines, 0&#x2F;1 coordinators
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Datacenter&lt;&#x2F;span&gt;&lt;span&gt; 2: 3&#x2F;12 machines, 0&#x2F;1 coordinators
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Datacenter&lt;&#x2F;span&gt;&lt;span&gt; 3: 3&#x2F;12 machines, 0&#x2F;1 coordinators
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Starting the Atomic workload
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Run&lt;&#x2F;span&gt;&lt;span&gt; test:AtomicWorkload start
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AtomicWorkload&lt;&#x2F;span&gt;&lt;span&gt; complete
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;checking&lt;&#x2F;span&gt;&lt;span&gt; test (AtomicWorkload)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt; test clients passed; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; test clients failed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Run&lt;&#x2F;span&gt;&lt;span&gt; test:AtomicWorkload Done.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt; tests passed; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt; tests failed.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Unseed:&lt;&#x2F;span&gt;&lt;span&gt; 66324
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Elapsed:&lt;&#x2F;span&gt;&lt;span&gt; 405.055622 simsec, 30.342000 real seconds
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This has been a &lt;strong&gt;major keypoint&lt;&#x2F;strong&gt; for us to develop and operate &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;materia&#x2F;&quot;&gt;Materia, Clever Cloud&#x27;s serverless database offer&lt;&#x2F;a&gt;, as we can enjoy the same Simulation framework used by FDB&#x27;s core engineers for layer engineering ü§Ø&lt;&#x2F;p&gt;
&lt;h2 id=&quot;closing-words&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#closing-words&quot; aria-label=&quot;Anchor link for: closing-words&quot;&gt;üîó&lt;&#x2F;a&gt;Closing words&lt;&#x2F;h2&gt;
&lt;p&gt;As with any open-source project, there is always more to accomplish, but I am quite satisfied with the current level of safety provided by the crate. I would like to express my gratitude to the FoundationDB community for developing the BindingTester, and former contributors to the crate.&lt;&#x2F;p&gt;
&lt;p&gt;I also would like to encourage everyone to explore the simulation framework. Integrating Rust code within this framework has allowed us to harness the full potential of simulation without the need to build our own, and it has forever changed my perspective on testing and software engineering.&lt;&#x2F;p&gt;
&lt;p&gt;There is a strong likelihood that future blog posts will focus on simulation, so feel free to explore the &lt;a href=&quot;&#x2F;tags&#x2F;simulation&#x2F;&quot;&gt;simulation tags&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
