<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>diving into on Pierre Zemb</title>
    <link>https://pierrezemb.fr/tags/diving-into/</link>
    <description>Recent content in diving into on Pierre Zemb</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;http://creativecommons.org/licenses/by/3.0/&#34;&gt;Some Rights Reserved&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 17 Nov 2019 10:24:27 +0100</lastBuildDate>
    
	<atom:link href="https://pierrezemb.fr/tags/diving-into/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Diving into Hbase&#39;s MemStore</title>
      <link>https://pierrezemb.fr/posts/diving-into-hbase-memstore/</link>
      <pubDate>Sun, 17 Nov 2019 10:24:27 +0100</pubDate>
      
      <guid>https://pierrezemb.fr/posts/diving-into-hbase-memstore/</guid>
      <description>Diving into is a blogpost serie where we are digging a specific part of of the project&amp;rsquo;s basecode. In this episode, we will digg into the implementation behind Hbase&amp;rsquo;s MemStore.
tl;dr: Hbase is using the ConcurrentSkipListMap.
What is the MemStore?  The memtable from the official BigTable paper is the equivalent of the MemStore in Hbase.
 As rows are sorted lexicographically in Hbase, when data comes in, you need to have some kind of a in-memory buffer to order those keys.</description>
    </item>
    
  </channel>
</rss>