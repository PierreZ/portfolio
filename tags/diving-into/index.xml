<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>diving into on Pierre Zemb</title>
    <link>https://pierrezemb.fr/tags/diving-into/</link>
    <description>Recent content in diving into on Pierre Zemb</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;http://creativecommons.org/licenses/by/3.0/&#34;&gt;Some Rights Reserved&lt;/a&gt;</copyright>
    <lastBuildDate>Fri, 18 Sep 2020 05:24:27 +0100</lastBuildDate><atom:link href="https://pierrezemb.fr/tags/diving-into/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Diving into ETCD&#39;s linearizable reads</title>
      <link>https://pierrezemb.fr/posts/diving-into-etcd-linearizable/</link>
      <pubDate>Fri, 18 Sep 2020 05:24:27 +0100</pubDate>
      
      <guid>https://pierrezemb.fr/posts/diving-into-etcd-linearizable/</guid>
      <description>Diving Into is a blogpost serie where we are digging a specific part of the project&amp;rsquo;s basecode. In this episode, we will digg into the implementation behind ETCD&amp;rsquo;s Linearizable reads.
 What is ETCD? From the official website:
 etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines. It gracefully handles leader elections during network partitions and can tolerate machine failure, even in the leader node.</description>
    </item>
    
    <item>
      <title>Diving into Kafka&#39;s Protocol</title>
      <link>https://pierrezemb.fr/posts/diving-into-kafka-protocol/</link>
      <pubDate>Sun, 08 Dec 2019 15:00:00 +0100</pubDate>
      
      <guid>https://pierrezemb.fr/posts/diving-into-kafka-protocol/</guid>
      <description>Diving Into is a blogpost serie where we are digging a specific part of of the project&amp;rsquo;s basecode. In this episode, we will digg into Kafka&amp;rsquo;s protocol.
 The protocol reference For the last few months, I worked a lot around Kafka&amp;rsquo;s protocols, first by creating a fully async Kafka to Pulsar Proxy in Rust, and now by contributing directly to KoP (Kafka On Pulsar). The full Kafka Protocol documentation is available here, but it does not offer a global view of what is happening for a classic Producer and Consumer exchange.</description>
    </item>
    
    <item>
      <title>Diving into Hbase&#39;s MemStore</title>
      <link>https://pierrezemb.fr/posts/diving-into-hbase-memstore/</link>
      <pubDate>Sun, 17 Nov 2019 10:24:27 +0100</pubDate>
      
      <guid>https://pierrezemb.fr/posts/diving-into-hbase-memstore/</guid>
      <description>Diving Into is a blogpost serie where we are digging a specific part of of the project&amp;rsquo;s basecode. In this episode, we will digg into the implementation behind Hbase&amp;rsquo;s MemStore.
 tl;dr: Hbase is using the ConcurrentSkipListMap.
What is the MemStore?  The memtable from the official BigTable paper is the equivalent of the MemStore in Hbase.
 As rows are sorted lexicographically in Hbase, when data comes in, you need to have some kind of a in-memory buffer to order those keys.</description>
    </item>
    
  </channel>
</rss>
