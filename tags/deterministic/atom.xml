<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Pierre Zemb&#x27;s Blog - deterministic</title>
    <subtitle>Pierre Zemb personal blog</subtitle>
    <link rel="self" type="application/atom+xml" href="https://pierrezemb.fr/tags/deterministic/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://pierrezemb.fr"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-12-09T00:00:00+00:00</updated>
    <id>https://pierrezemb.fr/tags/deterministic/atom.xml</id>
    <entry xml:lang="en">
        <title>Designing Rust FDB Workloads That Actually Find Bugs</title>
        <published>2025-12-09T00:00:00+00:00</published>
        <updated>2025-12-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/"/>
        <id>https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/</id>
        
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <category term="distributed-systems" schema="https://pierrezemb.fr/tags/" label="distributed-systems"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/writing-rust-fdb-workloads-that-find-bugs/">&lt;p&gt;After &lt;a href=&quot;&#x2F;posts&#x2F;diving-into-foundationdb-simulation&#x2F;&quot;&gt;one trillion CPU-hours of simulation testing&lt;&#x2F;a&gt;, FoundationDB has been stress-tested under conditions far worse than any production environment. Network partitions, disk failures, Byzantine faults. FDB handles them all. &lt;strong&gt;But what about your code?&lt;&#x2F;strong&gt; Your layer sits on top of FDB. Your indexes, your transaction logic, your retry handling. How do you know it survives chaos?&lt;&#x2F;p&gt;
&lt;p&gt;At Clever Cloud, we are building &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;materia&#x2F;&quot;&gt;Materia&lt;&#x2F;a&gt;, our serverless database product. The question haunted us: how do you ship layer code with the same confidence FDB has in its own? Our answer was to hack our way into FDB&#x27;s simulator using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;tree&#x2F;4ed057a&#x2F;foundationdb-simulation&quot;&gt;foundationdb-simulation&lt;&#x2F;a&gt;, a crate that compiles Rust to run inside FDB&#x27;s deterministic simulator. We&#x27;re the only language besides Flow that can pull this off.&lt;&#x2F;p&gt;
&lt;p&gt;The first seed triggered &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;developer-guide.html#transactions-with-unknown-results&quot;&gt;&lt;code&gt;commit_unknown_result&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, one of the most feared edge cases for FDB layer developers. When a connection drops, the client can&#x27;t know if the transaction committed. Our atomic counters were incrementing twice. In production, this surfaces once every few months under heavy load and during failures. In simulation? &lt;strong&gt;Almost immediately.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This post won&#x27;t walk you through the code mechanics. The &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;foundationdb-simulation&quot;&gt;foundationdb-simulation crate&lt;&#x2F;a&gt; and its &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;tree&#x2F;4ed057a&#x2F;foundationdb-simulation&quot;&gt;README&lt;&#x2F;a&gt; cover that. Instead, this teaches you how to &lt;strong&gt;design&lt;&#x2F;strong&gt; workloads that catch real bugs. Whether you&#x27;re a junior engineer or an LLM helping write tests, these principles will guide you.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-autonomous-testing-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-autonomous-testing-works&quot; aria-label=&quot;Anchor link for: why-autonomous-testing-works&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Why Autonomous Testing Works&lt;&#x2F;h2&gt;
&lt;p&gt;Traditional testing has you write specific tests for scenarios you imagined. But as Will Wilson put it at &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eZ1mmqlq-mY&quot;&gt;Bug Bash 2025&lt;&#x2F;a&gt;: &lt;strong&gt;&quot;The most dangerous bugs occur in states you never imagined possible.&quot;&lt;&#x2F;strong&gt; The key insight of autonomous testing (what FDB&#x27;s simulation embodies) is that instead of writing tests, you write a &lt;strong&gt;test generator&lt;&#x2F;strong&gt;. If you ran it for infinite time, it would eventually produce all possible tests you could have written. You don&#x27;t have infinite time, so instead you get a probability distribution over all possible tests. And probability distributions are leaky: they cover cases you never would have thought to test.&lt;&#x2F;p&gt;
&lt;p&gt;This is why simulation finds bugs so fast. You&#x27;re not testing what you thought to test. You&#x27;re testing what the probability distribution happens to generate, which includes edge cases you&#x27;d never have written explicitly. Add fault injection (a probability distribution over all possible ways the world can conspire to screw you) and now you&#x27;re finding bugs that would take months or years to surface in production.&lt;&#x2F;p&gt;
&lt;p&gt;This is what got me interested in simulation in the first place: how do you test the things you see during on-call shifts? Those weird transient bugs at 3 AM, the race conditions that happen once a month, the edge cases you only discover when production is on fire. Simulation shifts that complexity from SRE time to SWE time. What was a 3 AM page becomes a daytime debugging session. What was a high-pressure incident becomes a reproducible test case you can bisect, rewind, and experiment with freely.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-sequential-luck-problem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-sequential-luck-problem&quot; aria-label=&quot;Anchor link for: the-sequential-luck-problem&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Sequential Luck Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s why rare bugs are so hard to find: imagine a bug that requires three unlikely events in sequence. Each event has a 1&#x2F;1000 probability. Finding that bug requires 1&#x2F;1,000,000,000 attempts, roughly a billion tries with random testing. Research confirms this: &lt;a href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;conference&#x2F;osdi18&#x2F;presentation&#x2F;alquraan&quot;&gt;a study of network partition failures&lt;&#x2F;a&gt; found that 83% require 3+ events to manifest, 80% have catastrophic impact, and 21% cause permanent damage that persists after the partition heals. &lt;strong&gt;But here&#x27;s the good news for Rust workloads&lt;&#x2F;strong&gt;: you don&#x27;t solve this problem yourself. FDB&#x27;s simulation handles fault injection. BUGGIFY injects failures at arbitrary code points. Network partitions appear and disappear. Disks fail. Machines crash and restart. The simulator explores failure combinations that would take years to encounter in production.&lt;&#x2F;p&gt;
&lt;p&gt;Your job is different. You need to design operations that exercise interesting code paths. Not just reads and writes, but the edge cases your users will inevitably trigger. And you need to write invariants that CATCH bugs when simulation surfaces them. After a million injected faults, how do you prove your data is still correct? This division of labor is the key insight: FDB injects chaos, you verify correctness.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;designing-your-operation-alphabet&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#designing-your-operation-alphabet&quot; aria-label=&quot;Anchor link for: designing-your-operation-alphabet&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Designing Your Operation Alphabet&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;operation alphabet&lt;&#x2F;strong&gt; is the complete set of operations your workload can perform. This is where most workloads fail: they test happy paths with uniform distribution and miss the edge cases that break production. Think about three categories:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Normal operations&lt;&#x2F;strong&gt; with realistic weights. In production, maybe 80% of your traffic is reads, 15% is simple writes, 5% is complex updates. Your workload should reflect this, because bugs often hide in the interactions between operation types. A workload that runs 50% reads and 50% writes tests different code paths than one that runs 95% reads and 5% writes. Both might be valid, but they&#x27;ll find different bugs.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Adversarial inputs&lt;&#x2F;strong&gt; that customers will inevitably send. Empty strings. Maximum-length values. Null bytes in the middle of strings. Unicode edge cases. Boundary integers (0, -1, MAX_INT). Customers never respect your API specs, so model the chaos they create.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Nemesis operations&lt;&#x2F;strong&gt; that break things on purpose. Delete random data mid-test. Clear ranges that &quot;shouldn&#x27;t&quot; be cleared. Crash batch jobs mid-execution to test recovery. Run compaction every operation instead of daily. Create conflict storms where multiple clients hammer the same key. Approach the 10MB transaction limit. These operations stress your error handling and recovery paths. The rare operations are where bugs hide. That batch job running once a day in production? In simulation, you&#x27;ll hit its partial-failure edge case in minutes, but only if your operation alphabet includes it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;designing-invariants&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#designing-invariants&quot; aria-label=&quot;Anchor link for: designing-invariants&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Designing Invariants&lt;&#x2F;h2&gt;
&lt;p&gt;After simulation runs thousands of operations with injected faults, network partitions, and machine crashes, how do you know your data is still correct? Unlike FDB&#x27;s internal testing, Rust workloads can&#x27;t inject assertions at arbitrary code points. You verify correctness in the &lt;code&gt;check()&lt;&#x2F;code&gt; phase, after the chaos ends. The key question: &lt;strong&gt;&quot;After all this, how do I PROVE my data is still correct?&quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One critical tip: validate during &lt;code&gt;start()&lt;&#x2F;code&gt;, not just in &lt;code&gt;check()&lt;&#x2F;code&gt;.&lt;&#x2F;strong&gt; Don&#x27;t wait until the end to discover corruption. After each operation (or batch of operations), read back the data and verify it matches expectations. If you&#x27;re maintaining a counter, read it and check the bounds. If you&#x27;re building an index, query it immediately after insertion. Early validation catches bugs closer to their source, making debugging far easier. The &lt;code&gt;check()&lt;&#x2F;code&gt; phase is your final safety net, but continuous validation during execution is where you&#x27;ll catch most issues.&lt;&#x2F;p&gt;
&lt;p&gt;An invariant is just a property that must always hold, no matter what operations ran. If you&#x27;ve seen property-based testing, it&#x27;s the same idea: instead of &lt;code&gt;assertFalse(new User(GUEST).canUse(SAVED_CARD))&lt;&#x2F;code&gt;, you write &lt;code&gt;assertEquals(user.isAuthenticated(), user.canUse(SAVED_CARD))&lt;&#x2F;code&gt;. The first tests one case. The second tests a rule that holds for all cases.&lt;&#x2F;p&gt;
&lt;p&gt;Four patterns dominate invariant design:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Reference Models&lt;&#x2F;strong&gt; maintain an in-memory copy of expected state. Every operation updates both the database and the reference model. In &lt;code&gt;check()&lt;&#x2F;code&gt;, you compare them. If they diverge, something went wrong. Use &lt;code&gt;BTreeMap&lt;&#x2F;code&gt; (not &lt;code&gt;HashMap&lt;&#x2F;code&gt;) for deterministic iteration. This pattern works best for single-client workloads where you can track state locally.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Conservation Laws&lt;&#x2F;strong&gt; track quantities that must stay constant. Inventory transfers between warehouses shouldn&#x27;t change total inventory. Money transfers between accounts shouldn&#x27;t create or destroy money. Sum everything up and verify the conservation law holds. This pattern is elegant because it doesn&#x27;t require tracking individual operations, just the aggregate property.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Structural Integrity&lt;&#x2F;strong&gt; verifies data structures remain valid. If you maintain a secondary index, verify every index entry points to an existing record and every record appears in the index exactly once. If you maintain a linked list in FDB, traverse it and confirm every node is reachable. The cycle validation pattern (creating a circular list where nodes point to each other) is a classic technique from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;231f762&#x2F;fdbserver&#x2F;workloads&#x2F;Cycle.actor.cpp&quot;&gt;FDB&#x27;s own Cycle workload&lt;&#x2F;a&gt;. After chaos, traverse the cycle and verify you visit exactly N nodes.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Operation Logging&lt;&#x2F;strong&gt; solves two problems at once: &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; uncertainty and multi-client coordination. The trick from &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;231f762&#x2F;fdbserver&#x2F;workloads&#x2F;AtomicOps.actor.cpp&quot;&gt;FDB&#x27;s own AtomicOps workload&lt;&#x2F;a&gt;: &lt;strong&gt;log the intent alongside the operation in the same transaction&lt;&#x2F;strong&gt;. Write both your operation AND a log entry recording what you intended. Since they&#x27;re in the same transaction, they either both commit or neither does. No uncertainty. For multi-client workloads, each client logs under its own prefix (e.g., &lt;code&gt;log&#x2F;{client_id}&#x2F;&lt;&#x2F;code&gt;). In &lt;code&gt;check()&lt;&#x2F;code&gt;, client 0 reads all logs from all clients, replays them to compute expected state, and compares against actual state. If they diverge, something went wrong, and you&#x27;ll know exactly which operations succeeded. See the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;blob&#x2F;4ed057a&#x2F;foundationdb-simulation&#x2F;examples&#x2F;atomic&#x2F;lib.rs&quot;&gt;Rust atomic workload example&lt;&#x2F;a&gt; for a complete implementation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-determinism-rules&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-determinism-rules&quot; aria-label=&quot;Anchor link for: the-determinism-rules&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Determinism Rules&lt;&#x2F;h2&gt;
&lt;p&gt;FDB&#x27;s simulation is deterministic. Same seed, same execution path, same bugs. This is the superpower that lets you reproduce failures. But determinism is fragile. Break it, and you lose reproducibility. Five rules to remember:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;BTreeMap, not HashMap&lt;&#x2F;strong&gt;: HashMap iteration order is non-deterministic&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;context.rnd(), not rand::random()&lt;&#x2F;strong&gt;: All randomness must come from the seeded PRNG&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;context.now(), not SystemTime::now()&lt;&#x2F;strong&gt;: Use simulation time, not wall clock&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;db.run(), not manual retry loops&lt;&#x2F;strong&gt;: The framework handles retries and &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; correctly&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No tokio::spawn()&lt;&#x2F;strong&gt;: The simulation runs on a custom executor, spawning breaks it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;If you take nothing else from this post, memorize these. Break any of them and your failures become unreproducible. You&#x27;ll see a bug once and never find it again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;architecture-the-three-crate-pattern&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#architecture-the-three-crate-pattern&quot; aria-label=&quot;Anchor link for: architecture-the-three-crate-pattern&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Architecture: The Three-Crate Pattern&lt;&#x2F;h2&gt;
&lt;p&gt;Real production systems use tokio, gRPC, REST frameworks, all of which break simulation determinism. You can&#x27;t just drop your production binary into the simulator. The solution is separating your FDB operations into a simulation-friendly crate:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;my-project&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;â”œâ”€â”€ my-fdb-service&#x2F;      # Core FDB operations - NO tokio
&lt;&#x2F;span&gt;&lt;span&gt;â”œâ”€â”€ my-grpc-server&#x2F;      # Production layer (tokio + tonic)
&lt;&#x2F;span&gt;&lt;span&gt;â””â”€â”€ my-fdb-workloads&#x2F;    # Simulation tests
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The service crate contains pure FDB transaction logic with no async runtime dependency. The server crate wraps it for production. The workloads crate tests the actual service logic under simulation chaos. This lets you test your real production code, not a reimplementation that might have different bugs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;common-pitfalls&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#common-pitfalls&quot; aria-label=&quot;Anchor link for: common-pitfalls&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Common Pitfalls&lt;&#x2F;h2&gt;
&lt;p&gt;Beyond the determinism rules above, these mistakes will bite you:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Running setup or check on all clients.&lt;&#x2F;strong&gt; The framework runs multiple clients concurrently. If every client initializes data in &lt;code&gt;setup()&lt;&#x2F;code&gt;, you get duplicate initialization. If every client validates in &lt;code&gt;check()&lt;&#x2F;code&gt;, you get inconsistent results. Use &lt;code&gt;if self.client_id == 0&lt;&#x2F;code&gt; to ensure only one client handles initialization and validation.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Forgetting maybe_committed.&lt;&#x2F;strong&gt; The &lt;code&gt;db.run()&lt;&#x2F;code&gt; closure receives a &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; flag indicating the previous attempt might have succeeded. If you&#x27;re doing non-idempotent operations like atomic increments, you need either truly idempotent transactions or &lt;a href=&quot;&#x2F;posts&#x2F;automatic-txn-fdb-730&#x2F;&quot;&gt;automatic idempotency&lt;&#x2F;a&gt; in FDB 7.3+. Ignoring this flag means your workload might count operations twice.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Storing SimDatabase between phases.&lt;&#x2F;strong&gt; Each phase (&lt;code&gt;setup&lt;&#x2F;code&gt;, &lt;code&gt;start&lt;&#x2F;code&gt;, &lt;code&gt;check&lt;&#x2F;code&gt;) gets a fresh database reference. Storing the old one leads to undefined behavior. Always use the &lt;code&gt;db&lt;&#x2F;code&gt; parameter passed to each method.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Wrapping FdbError in custom error types.&lt;&#x2F;strong&gt; The &lt;code&gt;db.run()&lt;&#x2F;code&gt; retry mechanism checks if errors are retryable via &lt;code&gt;FdbError::is_retryable()&lt;&#x2F;code&gt;. If you wrap &lt;code&gt;FdbError&lt;&#x2F;code&gt; in your own error type (like &lt;code&gt;anyhow::Error&lt;&#x2F;code&gt; or a custom enum), the retry logic can&#x27;t see the underlying error and won&#x27;t retry. Keep &lt;code&gt;FdbError&lt;&#x2F;code&gt; unwrapped in your transaction closures, or ensure your error type preserves retryability information.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Assuming setup is safe from failures.&lt;&#x2F;strong&gt; BUGGIFY is disabled during &lt;code&gt;setup()&lt;&#x2F;code&gt;, so you might think transactions can&#x27;t fail. But simulation randomizes FDB knobs, which can still cause transaction failures. Always use &lt;code&gt;db.run()&lt;&#x2F;code&gt; with retry logic even in setup, or wrap your setup in a retry loop.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-real-value&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-real-value&quot; aria-label=&quot;Anchor link for: the-real-value&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Real Value&lt;&#x2F;h2&gt;
&lt;p&gt;That &lt;code&gt;commit_unknown_result&lt;&#x2F;code&gt; edge case appeared on our first simulation seed. In production, we&#x27;d still be hunting it months later. 30 minutes of simulation covers what would take 24 hours of chaos testing. But the real value of simulation testing isn&#x27;t just finding bugs, it&#x27;s &lt;strong&gt;forcing you to think about correctness.&lt;&#x2F;strong&gt; When you design a workload, you&#x27;re forced to ask: &quot;What happens when this retries during a partition?&quot; &quot;How do I verify correctness when transactions can commit in any order?&quot; &quot;What invariants must hold no matter what chaos occurs?&quot; Designing for chaos becomes natural. And if it survives simulation, it survives production.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with questions or to share your simulation workloads. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Diving into FoundationDB&#x27;s Simulation Framework</title>
        <published>2025-10-30T00:00:00+00:00</published>
        <updated>2025-10-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/diving-into-foundationdb-simulation/"/>
        <id>https://pierrezemb.fr/posts/diving-into-foundationdb-simulation/</id>
        
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <category term="distributed-systems" schema="https://pierrezemb.fr/tags/" label="distributed-systems"/>
        <category term="diving-into" schema="https://pierrezemb.fr/tags/" label="diving-into"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/diving-into-foundationdb-simulation/">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;tags&#x2F;diving-into&#x2F;&quot;&gt;Diving Into&lt;&#x2F;a&gt; is a blogpost series where we are digging a specific part of the project&#x27;s codebase. In this episode, we will dig into the implementation behind FoundationDB&#x27;s simulation framework.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;After years of on-call shifts running FoundationDB at Clever Cloud, here&#x27;s what I&#x27;ve learned: &lt;strong&gt;I&#x27;ve never been woken up by FDB&lt;&#x2F;strong&gt;. Every production incident traced back to our code, our infrastructure, our mistakes. Never FDB itself. That kind of reliability doesn&#x27;t happen by accident.&lt;&#x2F;p&gt;
&lt;p&gt;The secret? &lt;strong&gt;Deterministic simulation testing&lt;&#x2F;strong&gt;. FoundationDB runs the real database software (not mocks, not stubs) in a discrete-event simulator alongside randomized workloads and aggressive fault injection. All sources of nondeterminism are abstracted: network, disk, time, and random number generation. Multiple FDB servers communicate through a simulated network in a single-threaded process. The simulator injects machine crashes, rack failures, network partitions, disk corruption, bit flips. Every failure mode you can imagine, happening in rapid succession, deterministically. Same seed, same execution path, same bugs, every single time.&lt;&#x2F;p&gt;
&lt;p&gt;After roughly &lt;strong&gt;one trillion CPU-hours of simulation testing&lt;&#x2F;strong&gt;, FoundationDB has been stress-tested under conditions far worse than any production environment will ever encounter. The development environment is deliberately harsher than production: network partitions every few seconds, machine crashes mid-transaction, disks randomly swapped between nodes on reboot. If your code survives the simulator, production is easy.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve written before about &lt;a href=&quot;&#x2F;posts&#x2F;notes-about-foundationdb&#x2F;&quot;&gt;FoundationDB&lt;&#x2F;a&gt;, &lt;a href=&quot;&#x2F;posts&#x2F;simulation-driven-development&#x2F;&quot;&gt;simulation-driven development&lt;&#x2F;a&gt;, and &lt;a href=&quot;&#x2F;posts&#x2F;testing-prevention-vs-discovery&#x2F;&quot;&gt;testing prevention vs discovery&lt;&#x2F;a&gt;. Those posts cover the concepts and benefits. This post is different: &lt;strong&gt;this is how FoundationDB actually implements deterministic simulation&lt;&#x2F;strong&gt;. Interface swapping, deterministic event loops, BUGGIFY chaos injection, Flow actors, and the architecture that makes it all work. We&#x27;re going deep into the implementation.&lt;&#x2F;p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;
  &lt;img src=&quot;&#x2F;images&#x2F;fdb-simulation-deep-dive&#x2F;simulator-architecture.jpeg&quot; alt=&quot;FoundationDB Simulator Architecture&quot; &#x2F;&gt;
  &lt;p&gt;&lt;em&gt;FoundationDB&#x27;s simulation architecture: the same FDB server code runs in both the simulator process (using simulated I&#x2F;O) and the real world (using real I&#x2F;O)&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;h2 id=&quot;the-trick-interface-swapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-trick-interface-swapping&quot; aria-label=&quot;Anchor link for: the-trick-interface-swapping&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Trick: Interface Swapping&lt;&#x2F;h2&gt;
&lt;p&gt;The genius of FDB&#x27;s simulation is surprisingly simple: &lt;strong&gt;the same code runs in both production and simulation by swapping interface implementations&lt;&#x2F;strong&gt;. The global &lt;code&gt;g_network&lt;&#x2F;code&gt; pointer holds an &lt;code&gt;INetwork&lt;&#x2F;code&gt; interface. In production, this points to &lt;code&gt;Net2&lt;&#x2F;code&gt;, which creates real TCP connections using Boost.ASIO. In simulation, it points to &lt;code&gt;Sim2&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbrpc&#x2F;sim2.actor.cpp&quot;&gt;sim2.actor.cpp&lt;&#x2F;a&gt;), which creates &lt;code&gt;Sim2Conn&lt;&#x2F;code&gt; objects (fake connections that write to in-memory buffers).&lt;&#x2F;p&gt;
&lt;p&gt;When code needs to send data, it gets a &lt;code&gt;Reference&amp;lt;IConnection&amp;gt;&lt;&#x2F;code&gt; from the network layer. In production, that&#x27;s a real socket. In simulation, it&#x27;s &lt;code&gt;Sim2Conn&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbrpc&#x2F;sim2.actor.cpp&quot;&gt;sim2.actor.cpp&lt;&#x2F;a&gt;) with a &lt;code&gt;std::deque&amp;lt;uint8_t&amp;gt;&lt;&#x2F;code&gt; buffer. Network latency? The simulator adds &lt;code&gt;delay()&lt;&#x2F;code&gt; calls with values from &lt;code&gt;deterministicRandom()&lt;&#x2F;code&gt;. Packet loss? Just throw &lt;code&gt;connection_failed()&lt;&#x2F;code&gt;. Network partition? &lt;code&gt;Sim2Conn&lt;&#x2F;code&gt; checks &lt;code&gt;g_clogging.disconnected()&lt;&#x2F;code&gt; and refuses delivery. &lt;strong&gt;It&#x27;s all just memory operations with delays&lt;&#x2F;strong&gt;, running single-threaded and completely deterministic.&lt;&#x2F;p&gt;
&lt;p&gt;What makes this truly deterministic is &lt;code&gt;deterministicRandom()&lt;&#x2F;code&gt;, a seeded PRNG that replaces all randomness. Every network latency value, every backoff delay (like the &lt;code&gt;Peer&lt;&#x2F;code&gt;&#x27;s exponential reconnection timing), every process crash timing goes through the same deterministic stream. Same seed, same execution path, every single time. When a test fails after 1 trillion simulated operations, you can reproduce the exact failure by running with the same seed.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;biasing-the-simulator-buggify&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#biasing-the-simulator-buggify&quot; aria-label=&quot;Anchor link for: biasing-the-simulator-buggify&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Biasing the Simulator: BUGGIFY&lt;&#x2F;h3&gt;
&lt;p&gt;Most deep bugs need a rare combination of events. A network partition &lt;strong&gt;and&lt;&#x2F;strong&gt; a slow disk &lt;strong&gt;and&lt;&#x2F;strong&gt; a coordinator crash happening at the exact same moment. The probability of all three aligning randomly? Astronomical. You&#x27;d burn CPU-centuries waiting.&lt;&#x2F;p&gt;
&lt;p&gt;FoundationDB solves this with &lt;code&gt;BUGGIFY&lt;&#x2F;code&gt;, spread throughout the codebase. Each &lt;code&gt;BUGGIFY&lt;&#x2F;code&gt; point fires 25% of the time, deterministically, so every test explores a different corner of the state space (Alex Miller&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;transactional.blog&#x2F;simulation&#x2F;buggify&quot;&gt;excellent post on BUGGIFY&lt;&#x2F;a&gt; covers the implementation details).&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s take timeout handling in data distribution as an example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; DDShardTracker.actor.cpp (fdbserver&#x2F;DDShardTracker.actor.cpp:1508)
&lt;&#x2F;span&gt;&lt;span&gt;choose {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;when&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span&gt;(g_network-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isSimulated&lt;&#x2F;span&gt;&lt;span&gt;() &amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUGGIFY_WITH_PROB&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.01&lt;&#x2F;span&gt;&lt;span&gt;) ? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Never&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;                                                          : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fetchTopKShardMetrics_impl&lt;&#x2F;span&gt;&lt;span&gt;(self, req))) {}
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;when&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span&gt;(SERVER_KNOBS-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;DD_SHARD_METRICS_TIMEOUT&lt;&#x2F;span&gt;&lt;span&gt;))) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Timeout path
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Never()&lt;&#x2F;code&gt; future never completes. Literally hangs forever. This happens only in simulation (&lt;code&gt;g_network-&amp;gt;isSimulated()&lt;&#x2F;code&gt;) and with 1% probability (&lt;code&gt;BUGGIFY_WITH_PROB(0.01)&lt;&#x2F;code&gt;). When it fires, the operation gets stuck, forcing the timeout branch to execute. Simple, elegant failure injection.&lt;&#x2F;p&gt;
&lt;p&gt;But here&#x27;s the trick: &lt;strong&gt;the timeout value itself is also buggified&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ServerKnobs.cpp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;( DD_SHARD_METRICS_TIMEOUT, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;60.0 &lt;&#x2F;span&gt;&lt;span&gt;);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Production: 60 seconds
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt;( randomize &amp;amp;&amp;amp; BUGGIFY ) DD_SHARD_METRICS_TIMEOUT = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Simulation: 0.1 seconds!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Production timeout: 60 seconds. BUGGIFY timeout: 0.1 seconds (600x shorter). The shrinking timeout window means legitimate operations are far more likely to hit timeout paths. Even without &lt;code&gt;Never()&lt;&#x2F;code&gt; forcing a hang, simulated network delays and slow operations will trigger timeouts constantly. When &lt;code&gt;Never()&lt;&#x2F;code&gt; does fire, you get guaranteed timeout execution. Every knob marked &lt;code&gt;if (randomize &amp;amp;&amp;amp; BUGGIFY)&lt;&#x2F;code&gt; becomes a chaos variable. Timeouts shrink, cache sizes drop, I&#x2F;O patterns randomize.&lt;&#x2F;p&gt;
&lt;p&gt;This creates &lt;strong&gt;combinatorial explosion&lt;&#x2F;strong&gt;. FoundationDB has hundreds of randomized knobs. Each BUGGIFY-enabled test run picks a different configuration: maybe connection monitors are 4x slower, but file I&#x2F;O is using 32KB blocks, and cache size is 1000 entries, and reconnection delays are doubled. The next run? Completely different knob values. Same code, thousands of different operating environments. After one trillion simulated operations across countless test runs, you&#x27;ve stress-tested your code under scenarios that would take decades to encounter in production.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-developer-workflow-simulation-as-ci-cd&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-developer-workflow-simulation-as-ci-cd&quot; aria-label=&quot;Anchor link for: the-developer-workflow-simulation-as-ci-cd&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Developer Workflow: Simulation as CI&#x2F;CD&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s the FoundationDB developer experience: &lt;strong&gt;write code, run a few local simulation tests to catch obvious bugs, submit your merge request, then let the machines do the hard work&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Every pull request triggers &lt;strong&gt;hundreds of thousands of simulation tests&lt;&#x2F;strong&gt; running on hundreds of cores for hours before a human even begins code review. Different seeds explore different execution paths, different failure timings, different BUGGIFY configurations. Nightly testing runs tens of thousands more simulations, crawling through edge cases you&#x27;d never think to test manually.&lt;&#x2F;p&gt;
&lt;p&gt;In the early days when FoundationDB was still a company, they took this philosophy to its logical extreme: &lt;strong&gt;merge requests were automatically merged if simulation passed&lt;&#x2F;strong&gt;. No human approval needed. The simulation was so trusted that passing tests meant the code was production-ready. (You can hear more about FoundationDB&#x27;s early development culture on &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=C1nZzQqcPZw&amp;amp;list=PLh4UhOpNuTJO1S8xkfa3QmQzJemsUhuL8&amp;amp;index=6&quot;&gt;The BugBash Podcast&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;This changes how you think about distributed systems development. Instead of spending hours debugging race conditions or trying to mentally model all possible failure scenarios, you focus on building features. The simulation finds the edge cases. It discovers the bugs you&#x27;d never anticipate. It stress-tests your code under conditions that would take years to encounter in production.&lt;&#x2F;p&gt;
&lt;p&gt;The scale ramps up through the development cycle: thousands of seeds during merge request testing, tens of thousands in nightly runs, potentially millions during major release cycles. Each seed represents a completely different execution path through your code. By the time your change reaches production, it&#x27;s survived more chaos than most distributed systems see in their entire lifetime.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The confidence this gives developers is extraordinary&lt;&#x2F;strong&gt;: if your code survives hundreds of thousands of simulated disasters, production feels easy in comparison.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;flow-actors-and-cooperative-multitasking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#flow-actors-and-cooperative-multitasking&quot; aria-label=&quot;Anchor link for: flow-actors-and-cooperative-multitasking&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Flow: Actors and Cooperative Multitasking&lt;&#x2F;h2&gt;
&lt;p&gt;FoundationDB doesn&#x27;t use traditional threads. It uses Flow, a custom actor model built on C++. Here&#x27;s a simple example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;ACTOR Future&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;asyncAdd&lt;&#x2F;span&gt;&lt;span&gt;(Future&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span&gt;(f);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Suspend until f completes, then resume with its value
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; value + offset;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;ACTOR&lt;&#x2F;code&gt; keyword marks functions that can use &lt;code&gt;wait()&lt;&#x2F;code&gt;. When you call &lt;code&gt;wait(f)&lt;&#x2F;code&gt;, the actor &lt;strong&gt;suspends&lt;&#x2F;strong&gt;. It returns control to the event loop and resumes later when the &lt;code&gt;Future&lt;&#x2F;code&gt; completes, continuing with the result. No blocking. All asynchronous. Use the &lt;code&gt;state&lt;&#x2F;code&gt; keyword for variables that need to persist across multiple &lt;code&gt;wait()&lt;&#x2F;code&gt; calls.&lt;&#x2F;p&gt;
&lt;p&gt;If you know Rust&#x27;s async&#x2F;await, Flow is the same concept. &lt;code&gt;ACTOR&lt;&#x2F;code&gt; functions are like &lt;code&gt;async fn&lt;&#x2F;code&gt;, &lt;code&gt;wait()&lt;&#x2F;code&gt; is like &lt;code&gt;.await&lt;&#x2F;code&gt;, and &lt;code&gt;Future&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; is like Rust&#x27;s &lt;code&gt;Future&lt;&#x2F;code&gt;. The difference? Flow was built in 2009 for C++, and gets compiled by &lt;code&gt;actorcompiler.h&lt;&#x2F;code&gt; into state machines rather than relying on language support.&lt;&#x2F;p&gt;
&lt;p&gt;The same Flow code runs in both production and simulation. An actor waiting for network I&#x2F;O gets a real socket in production, a simulated buffer in simulation. The code doesn&#x27;t know the difference. The Flow documentation at &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;flow.html&quot;&gt;apple.github.io&#x2F;foundationdb&#x2F;flow.html&lt;&#x2F;a&gt; covers the full programming model.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;single-threaded-time-travel-the-event-loop&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#single-threaded-time-travel-the-event-loop&quot; aria-label=&quot;Anchor link for: single-threaded-time-travel-the-event-loop&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Single-Threaded Time Travel: The Event Loop&lt;&#x2F;h2&gt;
&lt;p&gt;Hundreds of actors running concurrently. Coordinators electing leaders, transaction logs replicating commits, storage servers handling reads. All happening in &lt;strong&gt;one thread&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The trick is cooperative multitasking. Actors yield control with &lt;code&gt;wait()&lt;&#x2F;code&gt;. When all actors are waiting, the event loop can &lt;strong&gt;advance simulated time&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;
    &lt;pre class=&quot;mermaid&quot;&gt;
        flowchart TD
    Start([Event Loop]) --&amp;gt; CheckReady{Any actors&amp;lt;br&amp;#x2F;&amp;gt;ready to run?}
    CheckReady --&amp;gt;|Yes| RunActor[Run next ready actor&amp;lt;br&amp;#x2F;&amp;gt;until it hits wait]
    RunActor --&amp;gt; CheckReady
    CheckReady --&amp;gt;|No, all waiting| CheckPending{Any pending&amp;lt;br&amp;#x2F;&amp;gt;futures?}
    CheckPending --&amp;gt;|Yes| AdvanceTime[Advance simulated clock&amp;lt;br&amp;#x2F;&amp;gt;to next event]
    AdvanceTime --&amp;gt; CheckReady
    CheckPending --&amp;gt;|No| Done([Simulation complete])
    &lt;&#x2F;pre&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Here&#x27;s the key insight: when all actors are blocked waiting on futures, the event loop finds the next scheduled event (the earliest timestamp) and &lt;strong&gt;jumps the simulated clock forward&lt;&#x2F;strong&gt; to that time. Then it wakes the actors waiting for that event and runs them until they &lt;code&gt;wait()&lt;&#x2F;code&gt; again.&lt;&#x2F;p&gt;
&lt;p&gt;Example: 100 storage servers each execute &lt;code&gt;wait(delay(deterministicRandom()-&amp;gt;random01() * 60.0))&lt;&#x2F;code&gt;. In wall-clock time, this takes microseconds. In simulated time, these delays are spread across 60 seconds. The event loop processes them in order, advancing time as it goes. &lt;strong&gt;Zero wall-clock time has passed. 60 simulated seconds have passed.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This gives you:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Compressed time&lt;&#x2F;strong&gt;: Years of uptime in seconds of testing. &lt;code&gt;wait(delay(86400.0))&lt;&#x2F;code&gt; simulates 24 hours instantly.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Perfect determinism&lt;&#x2F;strong&gt;: Single-threaded execution means no race conditions. Same seed, same event ordering, exact same execution path.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reproducibility&lt;&#x2F;strong&gt;: Test fails after 1 trillion simulated operations? Run again with the same seed, get the exact same failure at the exact same point.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;No actor ever blocks. They all cooperate, yielding control back to the event loop. This is the foundation that makes realistic cluster simulation possible.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;building-the-simulated-cluster&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-simulated-cluster&quot; aria-label=&quot;Anchor link for: building-the-simulated-cluster&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Building the Simulated Cluster&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we understand Flow actors and the event loop, let&#x27;s see what runs on it. SimulatedCluster &lt;strong&gt;builds an entire distributed cluster in memory&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;SimulatedCluster&lt;&#x2F;code&gt; starts by generating a random cluster configuration: 1-5 datacenters, 1-10+ machines per DC, different storage engines (memory, ssd, redwood-1), different replication modes (single, double, triple). Every test run gets a different topology.&lt;&#x2F;p&gt;
&lt;p&gt;The actor hierarchy looks like this: SimulatedCluster creates machine actors (&lt;code&gt;simulatedMachine&lt;&#x2F;code&gt;). Each machine actor creates process actors (&lt;code&gt;simulatedFDBDRebooter&lt;&#x2F;code&gt;). Each process actor runs &lt;strong&gt;actual fdbserver code&lt;&#x2F;strong&gt;. The machine actor sits in an infinite loop: wait for all processes to die, delay 10 simulated seconds, reboot.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The same fdbserver code that runs in production runs here&lt;&#x2F;strong&gt;. No mocks. No stubs. Real transaction logs writing to simulated disk. Real storage engines (RocksDB, Redwood). Real Paxos consensus. The only difference? &lt;code&gt;Sim2&lt;&#x2F;code&gt; network instead of &lt;code&gt;Net2&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;And of course, BUGGIFY shows up here too. Remember how BUGGIFY shrinks timeouts and injects failures? It also does something &lt;strong&gt;completely insane&lt;&#x2F;strong&gt; during machine reboots. When a machine reboots, the simulator can &lt;strong&gt;swap its disks&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; SimulatedCluster.actor.cpp - machine reboot
&lt;&#x2F;span&gt;&lt;span&gt;state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; swap = killType == ISimulator::KillType::Reboot &amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BUGGIFY_WITH_PROB&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.75&lt;&#x2F;span&gt;&lt;span&gt;) &amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;                  g_simulator-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;canSwapToMachine&lt;&#x2F;span&gt;&lt;span&gt;(localities.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;zoneId&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(swap) {
&lt;&#x2F;span&gt;&lt;span&gt;    availableFolders[localities.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dcId&lt;&#x2F;span&gt;&lt;span&gt;()].&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;push_back&lt;&#x2F;span&gt;&lt;span&gt;(myFolders);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Return my disks to pool
&lt;&#x2F;span&gt;&lt;span&gt;    myFolders = availableFolders[localities.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dcId&lt;&#x2F;span&gt;&lt;span&gt;()][randomIndex];  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Get random disks from pool
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;75% of the time when BUGGIFY is enabled, a rebooting machine gets &lt;strong&gt;random disks from the datacenter pool&lt;&#x2F;strong&gt;. Maybe it gets its own disks back. Maybe it gets another machine&#x27;s disks with completely different data. Maybe it gets the disks from a machine that was destroyed 10 minutes ago. Your storage server just woke up with someone else&#x27;s data (or no data at all). Can the cluster handle this? Can it detect the mismatch and rebuild correctly?&lt;&#x2F;p&gt;
&lt;p&gt;For extra chaos, there&#x27;s also &lt;code&gt;RebootAndDelete&lt;&#x2F;code&gt; which gives the machine &lt;strong&gt;brand new empty folders&lt;&#x2F;strong&gt;. No data. Fresh disks. This tests the actual failure mode of replacing a dead drive or provisioning a new machine.&lt;&#x2F;p&gt;
&lt;p&gt;Read that again. During testing, FoundationDB &lt;strong&gt;randomly swaps or deletes storage server data on reboot&lt;&#x2F;strong&gt;. If your distributed database doesn&#x27;t assume storage servers occasionally come back with amnesia or someone else&#x27;s memories, you&#x27;re not testing the real world. Because surely, no one has ever accidentally mounted the wrong volume in a Kubernetes deployment, right?&lt;&#x2F;p&gt;
&lt;p&gt;What you get from all this:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Real cluster behavior&lt;&#x2F;strong&gt;: Coordinators elect leaders, transaction logs replicate commits, storage servers handle reads&#x2F;writes, backup agents run&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Real failure modes&lt;&#x2F;strong&gt;: Process crashes, machine reboots, network partitions (via &lt;code&gt;g_clogging&lt;&#x2F;code&gt;), slow disks (via &lt;code&gt;AsyncFileNonDurable&lt;&#x2F;code&gt;), disk swaps, data loss&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Realistic topologies&lt;&#x2F;strong&gt;: Multi-region configurations, different storage engines, different replication modes, different machine counts&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;When you run a simulation test, SimulatedCluster boots this entire virtual cluster, lets it stabilize, runs workloads against it while injecting chaos, then validates correctness.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;workloads-stress-testing-under-chaos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#workloads-stress-testing-under-chaos&quot; aria-label=&quot;Anchor link for: workloads-stress-testing-under-chaos&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Workloads: Stress Testing Under Chaos&lt;&#x2F;h2&gt;
&lt;p&gt;30 seconds. 2500 transactions per second. Concurrent machines swapping edges in a distributed data structure while chaos engines inject failures. Let&#x27;s see if the database survives.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Simulation Overview
&lt;&#x2F;span&gt;&lt;span&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ Seed       â”† Replication      â”† Simulated Time â”† Real Time       â”† Storage Engine â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 1876983470 â”† triple           â”† 5m 47s         â”† 18s 891ms       â”† ssd-2          â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Timeline of Chaos Events
&lt;&#x2F;span&gt;&lt;span&gt;â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ Time (s) â”† Event Type         â”† Details                              â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â•žâ•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 87.234   â”† Coordinator Change â”† Triggering leader election           â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 92.156   â”† Process Reboot     â”† KillInstantly process at 10.0.4.2:3  â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 92.156   â”† Process Reboot     â”† KillInstantly process at 10.0.4.2:1  â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 95.871   â”† Coordinator Change â”† Triggering leader election           â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 103.445  â”† Process Reboot     â”† RebootAndDelete process at 10.0.2.1:4â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â”‚ 103.445  â”† Process Reboot     â”† RebootAndDelete process at 10.0.2.1:2â”‚
&lt;&#x2F;span&gt;&lt;span&gt;â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Chaos Summary
&lt;&#x2F;span&gt;&lt;span&gt;  Network Partitions: 187 events (max duration: 5.2s)
&lt;&#x2F;span&gt;&lt;span&gt;  Process Kills: 2 KillInstantly, 2 RebootAndDelete
&lt;&#x2F;span&gt;&lt;span&gt;  Coordinator Changes: 2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;The cluster survived.&lt;&#x2F;strong&gt; 187 network partitions. 4 process kills. 2 coordinator changes. 5 minutes of simulated time compressed into 18 seconds of wall-clock time. Every transaction completed correctly. The cycle invariant never broke.&lt;&#x2F;p&gt;
&lt;p&gt;How did we unleash this chaos? Here&#x27;s the test configuration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[configuration]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buggify &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;minimumReplication &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[test]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testTitle &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;CycleWithAttrition&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Cycle&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transactionsPerSecond &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2500.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;RandomClogging&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Attrition&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rollback&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;what-just-happened&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-just-happened&quot; aria-label=&quot;Anchor link for: what-just-happened&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;What Just Happened?&lt;&#x2F;h3&gt;
&lt;p&gt;Four concurrent workloads ran on the same simulated cluster for 30 seconds. &lt;strong&gt;Workloads&lt;&#x2F;strong&gt; are reusable scenario templates (180+ built-in in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;tree&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&quot;&gt;fdbserver&#x2F;workloads&#x2F;&lt;&#x2F;a&gt;) that either generate transactions or inject chaos.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The application workload&lt;&#x2F;strong&gt; we ran:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cycle&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;Cycle.actor.cpp&quot;&gt;Cycle.actor.cpp&lt;&#x2F;a&gt;): Hammered the database with 2500 transactions&#x2F;second, each one swapping edges in a distributed graph. Tests SERIALIZABLE isolation by maintaining a cycle invariant. If isolation breaks, the cycle splits or nodes vanish. We&#x27;ll dive deep into how this works below.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;The chaos workloads&lt;&#x2F;strong&gt; that tried to break it:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RandomClogging&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;RandomClogging.actor.cpp&quot;&gt;RandomClogging.actor.cpp&lt;&#x2F;a&gt;): Calls &lt;code&gt;g_simulator-&amp;gt;clogInterface(ip, duration)&lt;&#x2F;code&gt; to partition machines. Those &lt;strong&gt;187 network partitions&lt;&#x2F;strong&gt; we saw? This workload. Some lasted over 5 seconds.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Attrition&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;MachineAttrition.actor.cpp&quot;&gt;MachineAttrition.actor.cpp&lt;&#x2F;a&gt;): Calls &lt;code&gt;g_simulator-&amp;gt;killMachine()&lt;&#x2F;code&gt; and &lt;code&gt;g_simulator-&amp;gt;rebootMachine()&lt;&#x2F;code&gt;. The &lt;strong&gt;4 process kills&lt;&#x2F;strong&gt; (2 instant, 2 with deleted data)? This workload.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rollback&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;Rollback.actor.cpp&quot;&gt;Rollback.actor.cpp&lt;&#x2F;a&gt;): Forces proxy-to-TLog failures, triggering coordinator recovery. The &lt;strong&gt;2 coordinator changes&lt;&#x2F;strong&gt;? This workload.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Workloads are composable. The TOML format lets you stack them: &lt;code&gt;[configuration]&lt;&#x2F;code&gt; sets global parameters (BUGGIFY, replication), each &lt;code&gt;[[test.workload]]&lt;&#x2F;code&gt; adds another concurrent workload. Want to test atomic operations under network partitions? Stack &lt;code&gt;AtomicOps&lt;&#x2F;code&gt; + &lt;code&gt;RandomClogging&lt;&#x2F;code&gt;. Want to test backup during machine failures? Combine &lt;code&gt;BackupToBlob&lt;&#x2F;code&gt; + &lt;code&gt;Attrition&lt;&#x2F;code&gt;. Test files live in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;tree&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;tests&quot;&gt;tests&#x2F;&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;how-does-cycle-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-does-cycle-work&quot; aria-label=&quot;Anchor link for: how-does-cycle-work&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;How Does Cycle Work?&lt;&#x2F;h3&gt;
&lt;p&gt;Remember that test we just ran? Let&#x27;s break down how the &lt;code&gt;Cycle&lt;&#x2F;code&gt; workload actually works. It creates a directed graph where every node points to exactly one other node, forming a single cycle: &lt;code&gt;0â†’1â†’2â†’...â†’Nâ†’0&lt;&#x2F;code&gt;. Then it runs 2500 concurrent transactions per second, each one randomly swapping edges in the graph. Meanwhile, chaos workloads kill machines, partition the network, and force coordinator changes. &lt;strong&gt;If SERIALIZABLE isolation works correctly, the cycle never breaks&lt;&#x2F;strong&gt;. You always have exactly N nodes in one ring, never split cycles or dangling pointers.&lt;&#x2F;p&gt;
&lt;p&gt;Every workload implements four phases (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;include&#x2F;fdbserver&#x2F;workloads&#x2F;workloads.actor.h&quot;&gt;workloads.actor.h&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;SETUP&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;Cycle.actor.cpp&quot;&gt;Cycle.actor.cpp&lt;&#x2F;a&gt;): Creates &lt;code&gt;nodeCount&lt;&#x2F;code&gt; nodes. Each key stores the index of the next node in the cycle. Key 0 â†’ value 1, key 1 â†’ value 2, ..., key N-1 â†’ value 0.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;EXECUTION&lt;&#x2F;strong&gt;: Multiple concurrent &lt;code&gt;cycleClient&lt;&#x2F;code&gt; actors run this loop:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Pick random node &lt;code&gt;r&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Read three hops: &lt;code&gt;râ†’r2â†’r3â†’r4&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Swap the middle two edges: make &lt;code&gt;râ†’r3&lt;&#x2F;code&gt; and &lt;code&gt;r2â†’r4&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Commit&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This transaction reads 3 keys and writes 2. If isolation breaks, you could create cycles of the wrong length or lose nodes entirely.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;CHECK&lt;&#x2F;strong&gt;: One client reads the entire graph in a single transaction. Starting from node 0, follow pointers: 0â†’nextâ†’nextâ†’next. Count the hops. After exactly &lt;code&gt;nodeCount&lt;&#x2F;code&gt; hops, you must be back at node 0. If you get there earlier (cycle too short) or can&#x27;t get there (broken chain), the test fails. Also verifies transaction throughput met the expected rate.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;METRICS&lt;&#x2F;strong&gt;: Reports transactions completed, retry counts, latency percentiles.&lt;&#x2F;p&gt;
&lt;p&gt;This is the pattern all workloads follow: SETUP initializes data, EXECUTION generates load, CHECK verifies correctness, METRICS reports results. When you execute a test, SimulatedCluster boots the cluster, runs SETUP phases sequentially, then runs all EXECUTION phases concurrently (they&#x27;re Flow actors on the same event loop). After &lt;code&gt;testDuration&lt;&#x2F;code&gt;, CHECK phases verify correctness.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;This is what runs before every FoundationDB commit.&lt;&#x2F;strong&gt; Not once. Not a few times. Thousands of test runs with different seeds, different cluster configurations, different workload combinations. Application workloads generate realistic transactions. Chaos workloads inject failures. The CHECK phases prove correctness survived the chaos. This is why FoundationDB doesn&#x27;t fail in production. The simulator has already broken it every possible way, and every bug got fixed before shipping.&lt;&#x2F;p&gt;
&lt;p&gt;I generated that simulation output using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PierreZ&#x2F;fdb-sim-visualizer&quot;&gt;fdb-sim-visualizer&lt;&#x2F;a&gt;, a tool I wrote to parse simulation trace logs and understand what happened during testing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;verifying-correctness-building-reliable-workloads&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#verifying-correctness-building-reliable-workloads&quot; aria-label=&quot;Anchor link for: verifying-correctness-building-reliable-workloads&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Verifying Correctness: Building Reliable Workloads&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;But here&#x27;s the hard part: proving correctness when everything is randomized.&lt;&#x2F;strong&gt; The cluster survived. Transactions completed. The cycle invariant never broke... or did it? When you&#x27;re running 2500 transactions per second with random edge swaps under 187 network partitions, how do you &lt;strong&gt;prove&lt;&#x2F;strong&gt; nothing went wrong? You can&#x27;t just check if the database &quot;looks okay.&quot; You need &lt;strong&gt;proof&lt;&#x2F;strong&gt; the invariants held.&lt;&#x2F;p&gt;
&lt;p&gt;FoundationDB&#x27;s approach: &lt;strong&gt;track during EXECUTION, verify in CHECK.&lt;&#x2F;strong&gt; Three patterns emerge across the codebase:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pattern-1-reference-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pattern-1-reference-implementation&quot; aria-label=&quot;Anchor link for: pattern-1-reference-implementation&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Pattern 1: Reference Implementation&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;The challenge&lt;&#x2F;strong&gt;: How do you verify complex API behavior under chaos?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The solution&lt;&#x2F;strong&gt;: Run every operation twice. &lt;code&gt;ApiCorrectness&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;ApiCorrectness.actor.cpp&quot;&gt;ApiCorrectness.actor.cpp&lt;&#x2F;a&gt;) mirrors all operations in a simple &lt;code&gt;MemoryKeyValueStore&lt;&#x2F;code&gt; (just a &lt;code&gt;std::map&amp;lt;Key, Value&amp;gt;&lt;&#x2F;code&gt;). Every &lt;code&gt;transaction-&amp;gt;set(k, v)&lt;&#x2F;code&gt; also executes &lt;code&gt;store.set(k, v)&lt;&#x2F;code&gt; in memory. The CHECK phase reads from FDB and compares with the memory model. Mismatch = bug found.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pattern-2-operation-logging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pattern-2-operation-logging&quot; aria-label=&quot;Anchor link for: pattern-2-operation-logging&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Pattern 2: Operation Logging&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;The challenge&lt;&#x2F;strong&gt;: How do you verify atomic operations executed in the right order?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The solution&lt;&#x2F;strong&gt;: Log everything. &lt;code&gt;AtomicOps&lt;&#x2F;code&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;AtomicOps.actor.cpp&quot;&gt;AtomicOps.actor.cpp&lt;&#x2F;a&gt;) logs every operation to a separate keyspace. During EXECUTION: &lt;code&gt;atomicOp(ops_key, value)&lt;&#x2F;code&gt; on real data, &lt;code&gt;set(log_key, value)&lt;&#x2F;code&gt; to track what happened. During CHECK: replay all logged operations, compute what the final state should be, compare with actual database state.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pattern-3-invariant-tracking&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pattern-3-invariant-tracking&quot; aria-label=&quot;Anchor link for: pattern-3-invariant-tracking&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Pattern 3: Invariant Tracking&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;The challenge&lt;&#x2F;strong&gt;: How do you prove SERIALIZABLE isolation worked during chaos?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;The solution&lt;&#x2F;strong&gt;: Maintain a mathematical invariant that breaks if isolation fails. &lt;code&gt;Cycle&lt;&#x2F;code&gt; (from our test earlier) maintains &quot;exactly N nodes in one ring.&quot; During EXECUTION, random edge swaps must preserve the invariant. During CHECK, walk the graph: 0â†’nextâ†’nextâ†’next. After exactly N hops, you must be back at node 0. If you arrive earlier (cycle split) or can&#x27;t arrive (broken chain), isolation failed. The CHECK phase catches this immediately.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;using-clientid-for-work-distribution&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-clientid-for-work-distribution&quot; aria-label=&quot;Anchor link for: using-clientid-for-work-distribution&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Using clientId for Work Distribution&lt;&#x2F;h3&gt;
&lt;p&gt;Every workload gets &lt;code&gt;clientId&lt;&#x2F;code&gt; (0, 1, 2...) and &lt;code&gt;clientCount&lt;&#x2F;code&gt; (total clients). Three patterns:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Client 0 only&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;AtomicOps.actor.cpp&quot;&gt;AtomicOps.actor.cpp&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(clientId != &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Common for CHECK phases
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Partition keyspace&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;WatchAndWait.actor.cpp&quot;&gt;WatchAndWait.actor.cpp&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;uint64_t startNode = (nodeCount * clientId) &#x2F; clientCount;
&lt;&#x2F;span&gt;&lt;span&gt;uint64_t endNode = (nodeCount * (clientId + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)) &#x2F; clientCount;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Client 0: nodes 0-33, Client 1: nodes 34-66, Client 2: nodes 67-99
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Round-robin&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;blob&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;fdbserver&#x2F;workloads&#x2F;Watches.actor.cpp&quot;&gt;Watches.actor.cpp&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(i % clientCount == clientId)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Client 0: keys 0,3,6,9... Client 1: keys 1,4,7,10...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Use &lt;code&gt;clientId&lt;&#x2F;code&gt; to create concurrency (multiple clients hitting different keys) or coordinate work (one client checks, others generate load).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;randomize-everything&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#randomize-everything&quot; aria-label=&quot;Anchor link for: randomize-everything&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Randomize Everything&lt;&#x2F;h3&gt;
&lt;p&gt;The key to finding bugs: &lt;strong&gt;randomize every decision&lt;&#x2F;strong&gt;. Which keys to read? Random. How many operations per transaction? Random. Which atomic operation type? Random. Order of operations? Random. When to inject chaos? Random.&lt;&#x2F;p&gt;
&lt;p&gt;But use &lt;code&gt;deterministicRandom()&lt;&#x2F;code&gt; for all randomness. It&#x27;s a seeded PRNG. Same seed = same random choices = reproducible failures. When a test fails after 10 million operations, rerun with the same seed, get the exact same failure at the exact same point.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pattern-selection-guide&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#pattern-selection-guide&quot; aria-label=&quot;Anchor link for: pattern-selection-guide&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Pattern Selection Guide&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Testing&lt;&#x2F;th&gt;&lt;th&gt;Use Pattern&lt;&#x2F;th&gt;&lt;th&gt;Example Workload&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;API correctness&lt;&#x2F;td&gt;&lt;td&gt;Reference implementation&lt;&#x2F;td&gt;&lt;td&gt;ApiCorrectness&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Atomic operations&lt;&#x2F;td&gt;&lt;td&gt;Operation logging&lt;&#x2F;td&gt;&lt;td&gt;AtomicOps&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ACID guarantees&lt;&#x2F;td&gt;&lt;td&gt;Invariant tracking&lt;&#x2F;td&gt;&lt;td&gt;Cycle&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Backup&#x2F;restore&lt;&#x2F;td&gt;&lt;td&gt;Absence checking&lt;&#x2F;td&gt;&lt;td&gt;BackupCorrectness&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Chaos workloads (&lt;code&gt;RandomClogging&lt;&#x2F;code&gt;, &lt;code&gt;Attrition&lt;&#x2F;code&gt;, &lt;code&gt;Rollback&lt;&#x2F;code&gt;) don&#x27;t need CHECK phases. They just return &lt;code&gt;true&lt;&#x2F;code&gt;. They inject failures. Application workloads verify that correctness survived the chaos.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;writing-workloads-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#writing-workloads-in-rust&quot; aria-label=&quot;Anchor link for: writing-workloads-in-rust&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Writing Workloads in Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Remember those chaos workloads hammering the Cycle test? &lt;code&gt;RandomClogging&lt;&#x2F;code&gt;, &lt;code&gt;Attrition&lt;&#x2F;code&gt;, &lt;code&gt;Rollback&lt;&#x2F;code&gt;. All written in C++ Flow. But you can write workloads in &lt;strong&gt;Rust&lt;&#x2F;strong&gt; and compile them directly into the simulator. At Clever Cloud, we open-sourced &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;tree&#x2F;main&#x2F;foundationdb-simulation&quot;&gt;foundationdb-simulation&lt;&#x2F;a&gt;, which lets you implement the &lt;code&gt;RustWorkload&lt;&#x2F;code&gt; trait with &lt;code&gt;setup()&lt;&#x2F;code&gt;, &lt;code&gt;start()&lt;&#x2F;code&gt;, and &lt;code&gt;check()&lt;&#x2F;code&gt; methods using Rust&#x27;s async&#x2F;await:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;RustWorkload &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyWorkload {
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;setup&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: Database, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ctx&lt;&#x2F;span&gt;&lt;span&gt;: Context) -&amp;gt; Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Initialize test data
&lt;&#x2F;span&gt;&lt;span&gt;        db.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tx&lt;&#x2F;span&gt;&lt;span&gt;, _| async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;        }).await
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: Database, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;: Context) -&amp;gt; Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Generate load under simulation
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;_ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get_option&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nodeCount&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;            db.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tx&lt;&#x2F;span&gt;&lt;span&gt;, _| async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; value = tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;).await?;
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Your workload logic here
&lt;&#x2F;span&gt;&lt;span&gt;                Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;            }).await?;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;check&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;db&lt;&#x2F;span&gt;&lt;span&gt;: Database, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_ctx&lt;&#x2F;span&gt;&lt;span&gt;: Context) -&amp;gt; Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Verify correctness after chaos
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Your Rust code compiles to a shared library, FDB&#x27;s &lt;code&gt;ExternalWorkload&lt;&#x2F;code&gt; loads it at runtime via FFI, and your Rust async functions run on the same Flow event loop as the C++ cluster. The FFI boundary is managed by the &lt;code&gt;foundationdb-simulation&lt;&#x2F;code&gt; crate, which handles marshaling between Flow&#x27;s event loop and Rust futures. Same determinism, same reproducibility, same chaos injection. But you&#x27;re writing &lt;code&gt;async fn&lt;&#x2F;code&gt; instead of &lt;code&gt;ACTOR Future&amp;lt;Void&amp;gt;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&#x2F;blob&#x2F;main&#x2F;foundationdb-simulation&#x2F;examples&#x2F;atomic&#x2F;lib.rs&quot;&gt;complete example workload&lt;&#x2F;a&gt; testing atomic operations in ~100 lines of Rust.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simulation-at-clever-cloud-building-materia&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simulation-at-clever-cloud-building-materia&quot; aria-label=&quot;Anchor link for: simulation-at-clever-cloud-building-materia&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Simulation at Clever Cloud: Building Materia&lt;&#x2F;h3&gt;
&lt;p&gt;At Clever Cloud, we use simulation to build &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;blog&#x2F;features&#x2F;2024&#x2F;06&#x2F;11&#x2F;materia-kv-our-easy-to-use-serverless-key-value-database-is-available-to-all&#x2F;&quot;&gt;Materia&lt;&#x2F;a&gt;, our serverless database products. I&#x27;m the lead engineer behind Materia and the main maintainer of &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;foundationdb-rs&#x2F;foundationdb-rs&quot;&gt;foundationdb-rs&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We built a Rust SDK on top of FDB, similar to Apple&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;FoundationDB&#x2F;fdb-record-layer&quot;&gt;Record Layer&lt;&#x2F;a&gt;. It provides structured records, secondary indexes, query planning, and multi-tenant isolation. The result: a distributed transactional database built on FoundationDB&#x27;s guarantees.&lt;&#x2F;p&gt;
&lt;p&gt;FoundationDB is a hidden technology: you don&#x27;t use it directly, you build layers on top. But here&#x27;s the trick: &lt;strong&gt;patterns like index design, quota management, and schema management should be written once and consumed, not reimplemented in every product&lt;&#x2F;strong&gt;. Our SDK abstracts these patterns. Need secondary indexes? The SDK handles keyspace layout, index updates, and query planning. Need multi-tenant isolation? The SDK provides it. Need quota enforcement or permission management? &lt;strong&gt;We built a common control plane that works across all products&lt;&#x2F;strong&gt; built on the SDK. Write the hard distributed systems logic once, simulate it until it&#x27;s bulletproof, then reuse it everywhere.&lt;&#x2F;p&gt;
&lt;p&gt;Every merge request runs simulation tests in CI. We test SDK scenarios (indexing, query planning) and full product workloads under chaos. Multi-tenant isolation, concurrent queries, network partitions, machine crashes. The bugs we catch vary by layer. SDK changes catch nasty bugs like duplicated indexes during &lt;code&gt;maybe_committed&lt;&#x2F;code&gt; transactions. Product changes catch simpler errors like accidentally blocking FDB&#x27;s retry logic or breaking atomicity.&lt;&#x2F;p&gt;
&lt;p&gt;But the real value isn&#x27;t just bug detection. &lt;strong&gt;Instead of writing hundreds of unit tests, we write workloads that fuzz our code under chaos.&lt;&#x2F;strong&gt; One workload with randomized operations and deterministic chaos replaces dozens of hand-crafted test cases. When engineers write workloads for their features, they&#x27;re forced to think: &quot;What happens when this retries during a partition?&quot; &quot;How do I verify correctness when transactions can commit in any order?&quot; &lt;strong&gt;Designing for chaos&lt;&#x2F;strong&gt; becomes natural. The act of writing simulation workloads improves the design itself.&lt;&#x2F;p&gt;
&lt;p&gt;The confidence this gives a small team is extraordinary. When you can prove your code survives hundreds of network partitions and machine crashes before shipping, you sleep better at night. Our latest layer, an etcd-compatible API for managed Kubernetes, was built from the ground up with simulation in mind. We&#x27;re even &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;issues&#x2F;12343&quot;&gt;contributing features back to FoundationDB&lt;&#x2F;a&gt; to better support layers like ours.&lt;&#x2F;p&gt;
&lt;p&gt;If it survives simulation, it survives production.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;running-simulations-yourself&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-simulations-yourself&quot; aria-label=&quot;Anchor link for: running-simulations-yourself&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Running Simulations Yourself&lt;&#x2F;h2&gt;
&lt;p&gt;Think you can break FoundationDB? You don&#x27;t need to build from source or set up a cluster. Download a prebuilt &lt;code&gt;fdbserver&lt;&#x2F;code&gt; binary from the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;releases&quot;&gt;releases page&lt;&#x2F;a&gt;, create a test file, and unleash chaos:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Download fdbserver (Linux example, adjust for your platform)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wget&lt;&#x2F;span&gt;&lt;span&gt; https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;releases&#x2F;download&#x2F;7.3.27&#x2F;fdbserver.x86_64
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; +x fdbserver.x86_64
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Create the folder for traces
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mkdir&lt;&#x2F;span&gt;&lt;span&gt; events
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Run a simulation test with JSON trace output
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.&#x2F;fdbserver.x86_64 -r&lt;&#x2F;span&gt;&lt;span&gt; simulation&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -f&lt;&#x2F;span&gt;&lt;span&gt; Attritions.toml&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --trace-format&lt;&#x2F;span&gt;&lt;span&gt; json&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -L&lt;&#x2F;span&gt;&lt;span&gt; .&#x2F;events&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; --logsize&lt;&#x2F;span&gt;&lt;span&gt; 1GiB
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here are two test files to get you started. Save either as a &lt;code&gt;.toml&lt;&#x2F;code&gt; file and run with the command above.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Attritions.toml&lt;&#x2F;strong&gt; - Network partitions + machine crashes + database reconfigurations (the NemesisTest shown earlier):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[configuration]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buggify &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;minimumReplication &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[test]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testTitle &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;NemesisTest&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ReadWrite&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transactionsPerSecond &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;RandomClogging&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Network partitions
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swizzle &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Unclog in reversed order
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Attrition&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Machine crashes
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Rollback&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Proxy-to-TLog errors
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ChangeConfig&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# Database reconfigurations
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;coordinators &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;DiskFailureCycle.toml&lt;&#x2F;strong&gt; - Disk failures + bit flips during the Cycle workload:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span&gt;[configuration]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;minimumReplication &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;minimumRegions &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[[test]]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testTitle &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;DiskFailureCycle&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Cycle&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transactionsPerSecond &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2500.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    [[test.workload]]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testName &lt;&#x2F;span&gt;&lt;span&gt;= &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;DiskFailureInjection&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;testDuration &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;120.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stallInterval &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stallPeriod &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;throttlePeriod &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;30.0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;corruptFile &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;percentBitFlips &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The simulation generates JSON trace logs in &lt;code&gt;.&#x2F;events&#x2F;&lt;&#x2F;code&gt;. Parse them with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PierreZ&#x2F;fdb-sim-visualizer&quot;&gt;fdb-sim-visualizer&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For more test examples, check FoundationDB&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&#x2F;tree&#x2F;dfbb0ea72ce01ba87148ef67cf216200e8b249cd&#x2F;tests&quot;&gt;tests&#x2F;&lt;&#x2F;a&gt; directory. Hundreds of workload combinations testing every corner of the system.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-i-ve-never-been-woken-up-by-fdb&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-i-ve-never-been-woken-up-by-fdb&quot; aria-label=&quot;Anchor link for: why-i-ve-never-been-woken-up-by-fdb&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Why I&#x27;ve Never Been Woken Up by FDB&lt;&#x2F;h2&gt;
&lt;p&gt;After years of on-call and one trillion CPU-hours of simulation, I&#x27;ve never been woken up by FoundationDB. Now you know why.&lt;&#x2F;p&gt;
&lt;p&gt;Interface swapping lets the same code run in both production and simulation. Flow actors enable single-threaded determinism. The event loop compresses years into seconds. BUGGIFY injects chaos into every corner of the codebase. SimulatedCluster builds entire distributed systems in memory. Workloads generate realistic transactions while chaos engines try to break everything. And deterministic randomness guarantees every bug can be reproduced, diagnosed, and fixed before shipping.&lt;&#x2F;p&gt;
&lt;p&gt;The simulator has already broken FoundationDB in every possible way. Network partitions during coordinator elections. Machine crashes mid-transaction. Disks swapped between nodes on reboot. Bit flips. Slow I&#x2F;O. Every edge case, every race condition, every distributed systems nightmare. Found, fixed, and verified before production ever sees it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Want to try breaking FoundationDB yourself?&lt;&#x2F;strong&gt; Grab a test config from above, run the simulator, inject chaos, and see if you can find a bug that survived one trillion CPU-hours. If you do, the FDB team would love to hear about it.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your simulation testing experiences or FDB workloads. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Testing: prevention vs discovery</title>
        <published>2025-09-08T00:00:00+00:00</published>
        <updated>2025-09-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/testing-prevention-vs-discovery/"/>
        <id>https://pierrezemb.fr/posts/testing-prevention-vs-discovery/</id>
        
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <category term="llm" schema="https://pierrezemb.fr/tags/" label="llm"/>
        <category term="foundationdb" schema="https://pierrezemb.fr/tags/" label="foundationdb"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/testing-prevention-vs-discovery/">&lt;p&gt;While working on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PierreZ&#x2F;moonpool&quot;&gt;moonpool&lt;&#x2F;a&gt;, my hobby project for studying and backporting FoundationDB&#x27;s low-level engineering concepts (actor model, deterministic simulation, network fault injection), Claude Code did something remarkable: it found a bug I didn&#x27;t know existed on its own. Not through traditional testing, but through active exploration of edge cases I hadn&#x27;t considered.&lt;&#x2F;p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;testing-prevention-vs-discovery&#x2F;claude-moonpool.png&quot; alt=&quot;Claude Code autonomously debugging moonpool&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Claude identified a faulty seed triggering an edge case, debugged it locally using deterministic replay, and added it to the test suite. All by itself. ðŸ¤¯ &lt;strong&gt;This wasn&#x27;t prevention but discovery.&lt;&#x2F;strong&gt; It&#x27;s time to shift our testing paradigm from preventing regressions to actively discovering unknown bugs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;building-for-discovery&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-for-discovery&quot; aria-label=&quot;Anchor link for: building-for-discovery&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Building for Discovery&lt;&#x2F;h2&gt;
&lt;p&gt;The difference between prevention and discovery isn&#x27;t just philosophical but requires completely different system design. Moonpool was built from day one around three principles that enable active bug discovery:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Deterministic simulation&lt;&#x2F;strong&gt;: Every execution is completely reproducible. Given the same seed, the system makes identical decisions every time. This changes debugging from &quot;I can&#x27;t reproduce this&quot; to &quot;let me replay exactly what happened.&quot; More importantly, it lets LLMs explore the state space step by step without getting lost in non-deterministic noise.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Controlled failure injection&lt;&#x2F;strong&gt;: Built-in mechanisms intentionally introduce failures in controlled, reproducible ways. This includes timed failures like network delays and disconnects, plus &lt;a href=&quot;https:&#x2F;&#x2F;transactional.blog&#x2F;simulation&#x2F;buggify&quot;&gt;&quot;buggify&quot; mechanisms&lt;&#x2F;a&gt; that inject faulty internal state at strategic points in the code. Each buggify point is either enabled or disabled for an entire simulation run, creating consistent failure scenarios instead of random chaos. Instead of waiting for production to reveal edge cases, we force the system to encounter dangerous, bug-finding behaviors during development.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Observability through sometimes assertions&lt;&#x2F;strong&gt;: Borrowed from &lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&#x2F;docs&#x2F;best_practices&#x2F;sometimes_assertions&#x2F;&quot;&gt;Antithesis&lt;&#x2F;a&gt;, these verify we&#x27;re actually discovering the edge cases we think we&#x27;re testing. Here&#x27;s what they look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Verify that server binds sometimes fail during chaos testing
&lt;&#x2F;span&gt;&lt;span&gt;sometimes_assert!(
&lt;&#x2F;span&gt;&lt;span&gt;    server_bind_fails,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.bind_result.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;is_err&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Server bind should sometimes fail during chaos testing&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Ensure message queues sometimes approach capacity under load
&lt;&#x2F;span&gt;&lt;span&gt;sometimes_assert!(
&lt;&#x2F;span&gt;&lt;span&gt;    peer_queue_near_capacity,
&lt;&#x2F;span&gt;&lt;span&gt;    state.send_queue.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;() &amp;gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.config.max_queue_size as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f64 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.8&lt;&#x2F;span&gt;&lt;span&gt;) as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Message queue should sometimes approach capacity limit&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Traditional code coverage only tells you &quot;this line was reached.&quot; Sometimes assertions verify &quot;this interesting scenario actually happened.&quot; If a sometimes assertion never triggers across thousands of test runs, you know you&#x27;re not discovering the edge cases that matter.&lt;&#x2F;p&gt;
&lt;p&gt;These three elements shift testing from prevention to discovery. Instead of developers writing tests for scenarios they already know about, the system forces them to hit failure modes they haven&#x27;t thought of. For Claude, this meant it could explore the state space step by step, understanding not just what the code does, but what breaks it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-chaos-environment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-chaos-environment&quot; aria-label=&quot;Anchor link for: the-chaos-environment&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Chaos Environment&lt;&#x2F;h2&gt;
&lt;p&gt;Moonpool is currently limited to simulating TCP connections through its Peer abstraction, but even this narrow scope creates a surprisingly rich failure environment. Here&#x27;s what the chaos testing configuration looks like (borrowed from TigerBeetle&#x27;s approach):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;NetworkRandomizationRanges {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Create chaos testing ranges with connection cutting enabled for distributed systems testing
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;chaos_testing&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            bind_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;,                       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10-200Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            bind_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;,                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10-100Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            accept_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10000&lt;&#x2F;span&gt;&lt;span&gt;,                 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 1-10ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            accept_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15000&lt;&#x2F;span&gt;&lt;span&gt;,               &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 1-15ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            connect_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50000&lt;&#x2F;span&gt;&lt;span&gt;,                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 1-50ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            connect_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100000&lt;&#x2F;span&gt;&lt;span&gt;,             &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 5-100ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            read_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;,                        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 5-100Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            read_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;,                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10-200Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            write_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span&gt;,                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 50-1000Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            write_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2000&lt;&#x2F;span&gt;&lt;span&gt;,                  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 100-2000Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            clogging_probability_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.3&lt;&#x2F;span&gt;&lt;span&gt;,           &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10-30% chance of temporary network congestion
&lt;&#x2F;span&gt;&lt;span&gt;            clogging_base_duration_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;300000&lt;&#x2F;span&gt;&lt;span&gt;,    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 50-300ms congestion duration in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            clogging_jitter_duration_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;400000&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 100-400ms additional congestion variance in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            cutting_probability_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.10&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.20&lt;&#x2F;span&gt;&lt;span&gt;,          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 10-20% cutting chance per tick
&lt;&#x2F;span&gt;&lt;span&gt;            cutting_reconnect_base_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;200000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;800000&lt;&#x2F;span&gt;&lt;span&gt;,   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 200-800ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            cutting_reconnect_jitter_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100000&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;500000&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 100-500ms in Âµs
&lt;&#x2F;span&gt;&lt;span&gt;            cutting_max_cuts_range: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,                   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 1-2 cuts per connection max (exclusive upper bound)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Even with just TCP simulation, this creates a hostile environment where connections randomly fail, messages get delayed, and network operations experience unpredictable latencies. Each seed represents a different combination of timing and probability, creating unique failure scenarios.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;why-even-simple-network-code-needs-chaos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#why-even-simple-network-code-needs-chaos&quot; aria-label=&quot;Anchor link for: why-even-simple-network-code-needs-chaos&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Why Even Simple Network Code Needs Chaos&lt;&#x2F;h3&gt;
&lt;p&gt;You might think testing a simple peer implementation with fault injection is overkill, but production experience and research show otherwise. &lt;a href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi18-alquraan.pdf&quot;&gt;&quot;An Analysis of Network-Partitioning Failures in Cloud Systems&quot;&lt;&#x2F;a&gt; (OSDI &#x27;18) studied real-world failures and found:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;80%&lt;&#x2F;strong&gt; of network partition failures have catastrophic impact&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;27%&lt;&#x2F;strong&gt; lead to data loss (the most common consequence)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;90%&lt;&#x2F;strong&gt; of these failures are silent&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;21%&lt;&#x2F;strong&gt; cause permanent damage that persists even after the partition heals&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;83%&lt;&#x2F;strong&gt; need three additional events to manifest&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;That last point is crucial; exactly the kind of complex interaction that deterministic simulation with fault injection helps uncover.&lt;&#x2F;p&gt;
&lt;p&gt;My peer implementation only does simple ping-pong communication, yet it still took some work to make it robust enough to pass all the checks and assertions. It&#x27;s enough complexity for Claude to discover edge cases in connection handling, retry logic, and recovery mechanisms.&lt;&#x2F;p&gt;
&lt;p&gt;The breakthrough wasn&#x27;t that Claude wrote perfect code but that &lt;strong&gt;Claude could discover and explore failure scenarios I hadn&#x27;t thought to test, then use deterministic replay to debug and fix what went wrong.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-paradigm-shift&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-paradigm-shift&quot; aria-label=&quot;Anchor link for: the-paradigm-shift&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Paradigm Shift&lt;&#x2F;h2&gt;
&lt;p&gt;The difference between prevention and discovery completely changes how we think about software quality. &lt;strong&gt;Prevention testing asks &quot;did we break what used to work?&quot; Discovery testing asks &quot;what else is broken that we haven&#x27;t found yet?&quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This shift creates a powerful feedback loop for young engineers and LLMs alike. Both developers and LLMs learn what production failure really looks like, not the sanitized version we imagine. When Claude can explore failure scenarios step by step and immediately see the results through sometimes assertions, it becomes a discovery partner that finds edge cases human intuition misses.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t theoretical. It&#x27;s working in my hobby project today. Moonpool is definitely hobby-grade, but if a side project can enable LLM-assisted bug discovery, imagine what&#x27;s possible with production systems designed from the ground up for deterministic testing.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;foundationdb&quot;&gt;FoundationDB&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;tigerbeetle.com&#x2F;&quot;&gt;TigerBeetle&lt;&#x2F;a&gt;, and &lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&#x2F;&quot;&gt;Antithesis&lt;&#x2F;a&gt; communities have been practicing discovery-oriented testing for years. FoundationDB&#x27;s legendary reliability comes from exactly this approach; deterministic simulation that actively hunts for bugs rather than just preventing regressions. After operating FoundationDB in production for 3 years, I can confirm it&#x27;s by far the most robust and predictable distributed system I&#x27;ve encountered. Everything behaves exactly as documented, with none of the usual distributed systems surprises. I&#x27;ve written more about these ideas in my posts on &lt;a href=&quot;&#x2F;posts&#x2F;simulation-driven-development&#x2F;&quot;&gt;simulation-driven development&lt;&#x2F;a&gt; and &lt;a href=&quot;&#x2F;posts&#x2F;notes-about-foundationdb&#x2F;&quot;&gt;notes about FoundationDB&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;What&#x27;s new is that LLMs can now participate in this process.&lt;&#x2F;strong&gt; Through deterministic simulation and sometimes assertions, we&#x27;re not just telling the LLM &quot;write good code&quot; but showing it exactly what production failure looks like. If you&#x27;re curious about production-grade implementations of these ideas, check out &lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&#x2F;&quot;&gt;Antithesis&lt;&#x2F;a&gt;; their best hidden feature is that it works on any existing system without requiring a rewrite.&lt;&#x2F;p&gt;
&lt;p&gt;The tools exist. The techniques are proven. &lt;strong&gt;Testing must evolve from prevention to discovery.&lt;&#x2F;strong&gt; The future isn&#x27;t about writing better test cases but about building systems that actively reveal their own bugs.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your experiences with deterministic testing. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Unlocking Tokio&#x27;s Hidden Gems: Determinism, Paused Time, and Local Execution</title>
        <published>2025-05-18T18:13:02+02:00</published>
        <updated>2025-05-18T18:13:02+02:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/tokio-hidden-gems/"/>
        <id>https://pierrezemb.fr/posts/tokio-hidden-gems/</id>
        
        <category term="rust" schema="https://pierrezemb.fr/tags/" label="rust"/>
        <category term="tokio" schema="https://pierrezemb.fr/tags/" label="tokio"/>
        <category term="async" schema="https://pierrezemb.fr/tags/" label="async"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="concurrency" schema="https://pierrezemb.fr/tags/" label="concurrency"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/tokio-hidden-gems/">&lt;p&gt;Tokio is the powerhouse of asynchronous Rust, celebrated for its blazing speed and robust concurrency primitives. Many of us interact with its core components dailyâ€”&lt;code&gt;spawn&lt;&#x2F;code&gt;, &lt;code&gt;select!&lt;&#x2F;code&gt;, &lt;code&gt;async fn&lt;&#x2F;code&gt;, and the rich ecosystem of I&#x2F;O utilities. But beyond these well-trodden paths lie some incredibly potent, albeit less-publicized, features that can dramatically elevate your testing strategies, offer more nuanced task management, and grant you surgical control over your runtime&#x27;s execution.&lt;&#x2F;p&gt;
&lt;p&gt;Today, let&#x27;s pull back the curtain on a few of these invaluable tools: current-thread runtimes for embracing single-threaded flexibility with &lt;code&gt;!Send&lt;&#x2F;code&gt; types, seeded runtimes for taming non-determinism, and the paused clock for mastering time in your tests.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;effortless-send-futures-with-current-thread-runtimes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#effortless-send-futures-with-current-thread-runtimes&quot; aria-label=&quot;Anchor link for: effortless-send-futures-with-current-thread-runtimes&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Effortless &lt;code&gt;!Send&lt;&#x2F;code&gt; Futures with Current-Thread Runtimes&lt;&#x2F;h2&gt;
&lt;p&gt;While Tokio&#x27;s multi-threaded scheduler is a marvel for CPU-bound and parallel I&#x2F;O tasks, there are scenarios where a single-threaded execution model is simpler or even necessary. This is particularly true when dealing with types that are not &lt;code&gt;Send&lt;&#x2F;code&gt; (i.e., cannot be safely transferred across threads), such as &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, or when you want to avoid the overhead and complexity of synchronization primitives like &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; for state shared only within a single thread of execution.&lt;&#x2F;p&gt;
&lt;p&gt;Tokio&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.new_current_thread&quot;&gt;&lt;code&gt;Builder::new_current_thread()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; followed by &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.build_local&quot;&gt;&lt;code&gt;build_local()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (part of the same &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html&quot;&gt;&lt;code&gt;Builder&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; API) provides a streamlined way to create a runtime that executes tasks on the thread that created it. This setup inherently supports spawning &lt;code&gt;!Send&lt;&#x2F;code&gt; futures using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;fn.spawn_local.html&quot;&gt;&lt;code&gt;tokio::task::spawn_local&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; without needing to manually manage a &lt;code&gt;LocalSet&lt;&#x2F;code&gt; for basic cases. This approach aligns well with ongoing discussions in the Tokio community aimed at simplifying &lt;code&gt;!Send&lt;&#x2F;code&gt; task management.&lt;&#x2F;p&gt;
&lt;p&gt;This &lt;code&gt;build_local()&lt;&#x2F;code&gt; method not only simplifies handling &lt;code&gt;!Send&lt;&#x2F;code&gt; types today but also reflects the direction Tokio is heading. The Tokio team is exploring ways to make this even more integrated and ergonomic through a proposed &lt;strong&gt;&lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; type (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;issues&#x2F;6739&quot;&gt;#6739&lt;&#x2F;a&gt;). The vision for &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt; is a runtime that is inherently &lt;code&gt;!Send&lt;&#x2F;code&gt; (making &lt;code&gt;!Send&lt;&#x2F;code&gt; task management seamless within its context), where &lt;code&gt;tokio::spawn&lt;&#x2F;code&gt; and &lt;code&gt;tokio::task::spawn_local&lt;&#x2F;code&gt; would effectively behave identically.&lt;&#x2F;p&gt;
&lt;p&gt;This proposed enhancement is linked to a discussion about potentially deprecating the existing &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;task&#x2F;struct.LocalSet.html&quot;&gt;&lt;code&gt;tokio::task::LocalSet&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&#x2F;issues&#x2F;6741&quot;&gt;#6741&lt;&#x2F;a&gt;). While &lt;code&gt;LocalSet&lt;&#x2F;code&gt; currently offers fine-grained control for running &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks (e.g., within specific parts of larger, multi-threaded applications), it comes with complexities, performance overhead, and integration challenges that &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt; aims to resolve.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;So, what&#x27;s the takeaway for you?&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;For most scenarios requiring &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks on a single thread&lt;&#x2F;strong&gt; (like entire applications, test suites, or dedicated utility threads): Using &lt;code&gt;Builder::new_current_thread().build_local()&lt;&#x2F;code&gt; is the recommended, simpler, and more future-proof path. It embodies the principles of the proposed &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;If you need to embed &lt;code&gt;!Send&lt;&#x2F;code&gt; task execution within a specific scope of a larger, multi-threaded application&lt;&#x2F;strong&gt;: &lt;code&gt;LocalSet&lt;&#x2F;code&gt; is the current tool. However, be mindful of its potential deprecation and associated complexities. For new projects, evaluate if a dedicated thread using a &lt;code&gt;build_local()&lt;&#x2F;code&gt; runtime (or a future &lt;code&gt;LocalRuntime&lt;&#x2F;code&gt;) might offer a cleaner solution.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Essentially, Tokio is moving towards making single-threaded &lt;code&gt;!Send&lt;&#x2F;code&gt; execution more straightforward and deeply integrated. The &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.build_local&quot;&gt;&lt;code&gt;build_local()&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; method is a current gem that aligns you with this forward-looking approach.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s how you typically set one up (the &lt;code&gt;build_local()&lt;&#x2F;code&gt; way):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::runtime::Builder;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; rt = Builder::new_current_thread()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enable_all&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Enable I&#x2F;O, time, etc.
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_local&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Default::default()) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Builds a runtime on the current thread
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The runtime itself is the &amp;#39;LocalSet&amp;#39; in this context
&lt;&#x2F;span&gt;&lt;span&gt;    rt.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(async {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Spawn !Send futures here using tokio::task::spawn_local(...)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; For example:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rc_value = std::rc::Rc::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::task::spawn_local(async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;RC value: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, *rc_value);
&lt;&#x2F;span&gt;&lt;span&gt;        }).await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Running !Send futures on a current-thread runtime!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach simplifies designs where tasks don&#x27;t need to cross thread boundaries, allowing for more straightforward state management.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;taming-non-determinism-seeded-runtimes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#taming-non-determinism-seeded-runtimes&quot; aria-label=&quot;Anchor link for: taming-non-determinism-seeded-runtimes&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Taming Non-Determinism: Seeded Runtimes&lt;&#x2F;h2&gt;
&lt;p&gt;One of the challenges in testing concurrent systems is non-determinism. When multiple futures are ready to make progress simultaneously, such as in a &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;macro.select.html&quot;&gt;&lt;code&gt;tokio::select!&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; macro, the order in which they are polled can vary between runs. This can make reproducing and debugging race conditions or specific interleavings tricky.&lt;&#x2F;p&gt;
&lt;p&gt;Tokio offers a solution: &lt;strong&gt;seeded runtimes&lt;&#x2F;strong&gt;. By providing a specific &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.rng_seed&quot;&gt;&lt;code&gt;RngSeed&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; when building the runtime, you can make certain scheduler behaviors deterministic. This is particularly useful for &lt;code&gt;select!&lt;&#x2F;code&gt; statements involving multiple futures that become ready around the same time.&lt;&#x2F;p&gt;
&lt;p&gt;Consider this example, which demonstrates how a seed can influence which future &#x27;wins&#x27; a &lt;code&gt;select!&lt;&#x2F;code&gt; race:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::runtime::{Builder, RngSeed};
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::time::{sleep, Duration};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Example function to show deterministic select!
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;demo_deterministic_select&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Try changing this seed to see the select! behavior change (but consistently per seed).
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; seed = RngSeed::from_bytes(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;my_fixed_seed_001&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; e.g., let seed = RngSeed::from_bytes(b&amp;quot;another_seed_002&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; rt = Builder::new_current_thread()
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enable_time&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Pausing the clock is crucial here to ensure both tasks become ready 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; at the *exact same logical time* after we call `tokio::time::advance`.
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This makes the seed&amp;#39;s role in tie-breaking very clear.
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;start_paused&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rng_seed&lt;&#x2F;span&gt;&lt;span&gt;(seed)     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Apply the seed for deterministic polling order
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;build_local&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Default::default())
&lt;&#x2F;span&gt;&lt;span&gt;        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Now, let&amp;#39;s run some tasks and see select! in action.
&lt;&#x2F;span&gt;&lt;span&gt;    rt.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(async {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task_a = async {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Task A finished.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Result from A&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task_b = async {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;            println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Task B finished.&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Result from B&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;        };
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Advance time so both sleeps complete and both tasks become ready.
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::time::advance(Duration::from_millis(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; With the same seed, the select! macro will consistently pick the same
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; branch if both are ready. Change the seed to see if the other branch gets picked.
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::select! {
&lt;&#x2F;span&gt;&lt;span&gt;            res_a = task_a =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Select chose Task A, result: &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, res_a);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            res_b = task_b =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Select chose Task B, result: &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, res_b);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;demo_deterministic_select&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;mastering-time-paused-clock-and-auto-advancement&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mastering-time-paused-clock-and-auto-advancement&quot; aria-label=&quot;Anchor link for: mastering-time-paused-clock-and-auto-advancement&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Mastering Time: Paused Clock and Auto-Advancement&lt;&#x2F;h2&gt;
&lt;p&gt;Testing time-dependent behavior (timeouts, retries, scheduled tasks) can be slow and flaky. Waiting for real seconds or minutes to pass during tests is inefficient. Tokio&#x27;s time facilities can be &lt;strong&gt;paused&lt;&#x2F;strong&gt; and &lt;strong&gt;manually advanced&lt;&#x2F;strong&gt;, giving you precise control over the flow of time within your tests.&lt;&#x2F;p&gt;
&lt;p&gt;When you initialize a runtime with &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;tokio&#x2F;latest&#x2F;tokio&#x2F;runtime&#x2F;struct.Builder.html#method.start_paused&quot;&gt;&lt;code&gt;start_paused(true)&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;, the runtime&#x27;s clock will not advance automatically based on wall-clock time. Instead, you use &lt;code&gt;tokio::time::advance(Duration)&lt;&#x2F;code&gt; to move time forward explicitly.&lt;&#x2F;p&gt;
&lt;p&gt;What&#x27;s particularly neat is Tokio&#x27;s &lt;strong&gt;auto-advance&lt;&#x2F;strong&gt; feature when the runtime is paused and idle. This works because Tokio&#x27;s runtime separates the &lt;strong&gt;executor&lt;&#x2F;strong&gt; (which polls your async code until it&#x27;s blocked) from the &lt;strong&gt;reactor&lt;&#x2F;strong&gt; (which wakes tasks based on I&#x2F;O or timer events). If all tasks are sleeping, the executor is idle. The reactor can then identify the next scheduled timer, allowing Tokio to automatically advance its clock to that point. This prevents tests from hanging indefinitely while still allowing for controlled time progression.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s your example illustrating this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;tokio::time::{Duration, Instant, sleep};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;auto_advance_kicks_in_when_idle_example&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; start = Instant::now();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Sleep for 5 seconds. Since the runtime is paused, this would normally hang.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; However, if no other tasks are active, Tokio auto-advances time.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span&gt;(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; elapsed = start.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;elapsed&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; This will be exactly 5 seconds (simulated time)
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(elapsed, Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Elapsed (simulated): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, elapsed);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this scenario, &lt;code&gt;sleep(Duration::from_secs(5)).await&lt;&#x2F;code&gt; doesn&#x27;t cause your test to wait for 5 real seconds. Because the clock is paused and this &lt;code&gt;sleep&lt;&#x2F;code&gt; is the only pending timed event, Tokio advances its internal clock by 5 seconds, allowing the sleep to complete almost instantaneously in real time. This makes testing timeouts, scheduled events, and other time-sensitive logic fast and reliable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Tokio offers more than just speed; it&#x27;s a powerful toolkit. Features like current-thread runtimes for &lt;code&gt;!Send&lt;&#x2F;code&gt; tasks, seeded runtimes for deterministic tests, and a controllable clock for time-based logic help build robust and debuggable async Rust applications. These &#x27;hidden gems&#x27; allow you to confidently handle complex concurrency and testing. So, explore Tokio&#x27;s depthâ€”the right tool for your challenge might be closer than you think.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your thoughts. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>What if we embraced simulation-driven development?</title>
        <published>2025-04-18T11:12:12+02:00</published>
        <updated>2025-04-18T11:12:12+02:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/simulation-driven-development/"/>
        <id>https://pierrezemb.fr/posts/simulation-driven-development/</id>
        
        <category term="distributed" schema="https://pierrezemb.fr/tags/" label="distributed"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="reliability" schema="https://pierrezemb.fr/tags/" label="reliability"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/simulation-driven-development/">&lt;p&gt;This article has been translated from my original French presentation at the upcoming Devoxx France 2025, titled &quot;&lt;a href=&quot;https:&#x2F;&#x2F;docs.google.com&#x2F;presentation&#x2F;d&#x2F;1xm4yNGnV2Oi8Lk3ZHEvg4aDMNEFieSmW06CkItCigSc&#x2F;edit?usp=sharing&quot;&gt;What if we embraced simulation-driven development?&lt;&#x2F;a&gt;&quot;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-tale-of-a-bug&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-tale-of-a-bug&quot; aria-label=&quot;Anchor link for: the-tale-of-a-bug&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Tale of a Bug&lt;&#x2F;h2&gt;
&lt;p&gt;As a software engineer, my responsibilities include debugging distributed systems during on-call shifts. My tendency to attract peculiar issues during these shifts earned me the nickname &quot;Black Cat&quot;. Let me share a particularly memorable incident:&lt;&#x2F;p&gt;
&lt;p&gt;One of the most memorable incidents happened when a &lt;strong&gt;network partition&lt;&#x2F;strong&gt; completely disrupted a 70+ node Apache Hadoop cluster. The system was in disarray, with nodes confused about &lt;strong&gt;block replication&lt;&#x2F;strong&gt; and &lt;strong&gt;management&lt;&#x2F;strong&gt;. After the network issue was resolved, we decided to &lt;strong&gt;restart the cluster&lt;&#x2F;strong&gt;...&lt;&#x2F;p&gt;
&lt;p&gt;But it wouldn&#x27;t come back online.&lt;&#x2F;p&gt;
&lt;p&gt;The reason? The system was encountering a &lt;code&gt;NullPointerException&lt;&#x2F;code&gt; during startup due to its faulty state. The cluster was too slow to restart properly because of how severely degraded it had become after the network partition. This bug had actually been fixed in newer versions of &lt;strong&gt;HDFS&lt;&#x2F;strong&gt;, but we were running an older release.&lt;&#x2F;p&gt;
&lt;p&gt;The solution required &lt;strong&gt;patching the Hadoop codebase&lt;&#x2F;strong&gt; by &lt;strong&gt;backporting the fix&lt;&#x2F;strong&gt;, &lt;strong&gt;recompiling&lt;&#x2F;strong&gt;, and &lt;strong&gt;distributing the new jar&lt;&#x2F;strong&gt; across all nodesâ€”not exactly what you want to be doing during an active incident. Rolling out patches to a distributed system while it&#x27;s already &quot;on fire&quot; is rarely recommended, but we had no choice.&lt;&#x2F;p&gt;
&lt;p&gt;This is exactly the type of code that feels disconnected from production requirementsâ€”the bug appeared at the worst possible moment, during recovery, when the system was most vulnerable.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-development-production-gap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-development-production-gap&quot; aria-label=&quot;Anchor link for: the-development-production-gap&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Development-Production Gap&lt;&#x2F;h2&gt;
&lt;p&gt;This incident highlights a fundamental truth in software engineering: &lt;strong&gt;production environments are vastly different from development environments&lt;&#x2F;strong&gt;. The gap between them is comparable to the difference between passing a written driving test and actually driving on a busy highway during rush hour.&lt;&#x2F;p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;
    &lt;pre class=&quot;mermaid&quot;&gt;
        flowchart LR
    S[&amp;quot;Your System&amp;quot;] 
    U[&amp;quot;Your Users&amp;quot;]
    W[&amp;quot;The World&amp;quot;]
    
    U --&amp;gt; S
    W --&amp;gt; S
    &lt;&#x2F;pre&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;In development, everything is &lt;strong&gt;controlled&lt;&#x2F;strong&gt;, &lt;strong&gt;clean&lt;&#x2F;strong&gt;, and &lt;strong&gt;predictable&lt;&#x2F;strong&gt;. In production:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Users do &lt;strong&gt;unexpected things&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Systems operate under &lt;strong&gt;pressure&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Components fail in &lt;strong&gt;complex ways&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Edge cases&lt;&#x2F;strong&gt; occur regularly&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Being on-call forces you to confront this reality. The pager is an unforgiving teacher, but is there a better way to instill a production mindset without throwing engineers into the deep end of incident response?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-testing-problem&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-testing-problem&quot; aria-label=&quot;Anchor link for: the-testing-problem&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The Testing Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s consider a standard e-commerce API with multiple dimensions of variability:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;User Types: Guest, Logged-in, Premium, Business (4)&lt;&#x2F;li&gt;
&lt;li&gt;Payment Methods: Credit Card, PayPal, Apple Pay, Gift Card, Bank Transfer (5)&lt;&#x2F;li&gt;
&lt;li&gt;Delivery Options: Standard, Express, In-Store Pickup, Same-Day (4)&lt;&#x2F;li&gt;
&lt;li&gt;Promotions: Yes, No, Expired (3)&lt;&#x2F;li&gt;
&lt;li&gt;Inventory Status: In Stock, Low Stock, Out of Stock, Preorder (4)&lt;&#x2F;li&gt;
&lt;li&gt;Currency: USD, EUR, GBP, JPY (4)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Testing all possible combinations requires 4Ã—5Ã—4Ã—3Ã—4Ã—4 = 3,840 unique test casesâ€”and that&#x27;s just for the happy path! Add error conditions, network failures, and other edge cases, and this number explodes exponentially.&lt;&#x2F;p&gt;
&lt;p&gt;This is why comprehensive end-to-end testing is so difficult. Every new feature multiplies the complexity, and bugs often hide in rare combinations of conditions that we never thought to test.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-world-is-harsh&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-world-is-harsh&quot; aria-label=&quot;Anchor link for: the-world-is-harsh&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;The World Is Harsh&lt;&#x2F;h2&gt;
&lt;p&gt;Meanwhile, the real world is even more chaotic than our test cases. Research papers like &quot;&lt;a href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;osdi18-alquraan.pdf&quot;&gt;An Analysis of Network-Partitioning Failures in Cloud Systems&lt;&#x2F;a&gt;&quot; (OSDI &#x27;18) and &quot;&lt;a href=&quot;https:&#x2F;&#x2F;sigops.org&#x2F;s&#x2F;conferences&#x2F;hotos&#x2F;2021&#x2F;papers&#x2F;hotos21-s11-bronson.pdf&quot;&gt;Metastable Failures in Distributed Systems&lt;&#x2F;a&gt;&quot; (HotOS &#x27;21) document just how complex failure modes can be in production.&lt;&#x2F;p&gt;
&lt;p&gt;In a &lt;a href=&quot;https:&#x2F;&#x2F;qconlondon.com&#x2F;london-2015&#x2F;system&#x2F;files&#x2F;keynotes-slides&#x2F;2015-03%20QCon%20(john%20wilkes).pdf&quot;&gt;presentation by John Wilkes (Google) at QCon London 2015&lt;&#x2F;a&gt;, a 2,000-machine service will experience more than 10 machine crashes per dayâ€”and this is considered normal, not exceptional. When you operate at scale, failures become a constant background noise rather than exceptional events.&lt;&#x2F;p&gt;
&lt;p&gt;And yes, your &lt;strong&gt;microservices architecture&lt;&#x2F;strong&gt; is absolutely a distributed system susceptible to these issues.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sre-vs-swe-perspectives&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sre-vs-swe-perspectives&quot; aria-label=&quot;Anchor link for: sre-vs-swe-perspectives&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;SRE vs. SWE Perspectives&lt;&#x2F;h2&gt;
&lt;p&gt;There&#x27;s often a gap between the Software Engineer (SWE) perspective and the Site Reliability Engineer (SRE) perspective:&lt;&#x2F;p&gt;
&lt;p&gt;SWEs tend to focus on:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Development environments (which are completely different from production)&lt;&#x2F;li&gt;
&lt;li&gt;Feature implementations&lt;&#x2F;li&gt;
&lt;li&gt;Code that passes tests (but may not account for real-world complexity)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;SREs worry about:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;System interactions in production under pressure&lt;&#x2F;li&gt;
&lt;li&gt;Complex, unpredictable failure modes&lt;&#x2F;li&gt;
&lt;li&gt;Recovery mechanisms when things are already broken&lt;&#x2F;li&gt;
&lt;li&gt;Being paged at 3 AM to fix critical issues alone&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The question then becomes: &lt;strong&gt;How can we help developers gain a better understanding of production realities without subjecting them to the trial-by-fire of on-call rotations?&lt;&#x2F;strong&gt; How might we bridge this gap between development and operations, creating environments where engineers can experience production-like conditions safely, learn from failures, and build more resilient systems from the beginning?&lt;&#x2F;p&gt;
&lt;p&gt;We need to test not just our expected use cases, but the &lt;strong&gt;&quot;worse&quot; versions of both our users and the world&lt;&#x2F;strong&gt;. How do we accomplish this comprehensively?&lt;&#x2F;p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;
    &lt;pre class=&quot;mermaid&quot;&gt;
        flowchart LR
    S[&amp;quot;Your System&amp;quot;] 
    U[&amp;quot;Your worst Users&amp;quot;]
    W[&amp;quot;The worst World&amp;quot;]
    
    U --&amp;gt; S
    W --&amp;gt; S
    &lt;&#x2F;pre&gt;
&lt;&#x2F;div&gt;&lt;h2 id=&quot;deterministic-simulation-testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deterministic-simulation-testing&quot; aria-label=&quot;Anchor link for: deterministic-simulation-testing&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Deterministic Simulation Testing&lt;&#x2F;h2&gt;
&lt;p&gt;The solution lies in a strategy that&#x27;s both robust and practical: &lt;strong&gt;Deterministic Simulation Testing (DST)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For effective testing of complex distributed systems, we need an approach that satisfies three key requirements:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fast and debuggable testing&lt;&#x2F;strong&gt; â†’ We achieve this with a single-threaded approach that uses a deterministic event loop, making issues perfectly reproducible&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Testing the entire system at once&lt;&#x2F;strong&gt; â†’ By packaging everything into a single binary with simulated network interactions, we can test complex distributed behaviors without actual network infrastructure&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Robust against unknown issues&lt;&#x2F;strong&gt; â†’ Through randomized testing with controlled entropy injection, we discover edge cases that we wouldn&#x27;t think to test explicitly&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;These three elements work together to create a powerful testing methodology that&#x27;s both practical to implement and effective at finding real-world issues.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s see how we can simulate both our users and the world?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-to-simulate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-to-simulate&quot; aria-label=&quot;Anchor link for: how-to-simulate&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;How to simulate?&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;simulating-users-randomized-input-and-property-based-testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simulating-users-randomized-input-and-property-based-testing&quot; aria-label=&quot;Anchor link for: simulating-users-randomized-input-and-property-based-testing&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Simulating Users: Randomized Input and Property-Based Testing&lt;&#x2F;h3&gt;
&lt;p&gt;Instead of writing thousands of individual test cases, we can use &lt;strong&gt;property-based testing&lt;&#x2F;strong&gt; to generate randomized inputs and verify system properties. This approach is not new and is well-known for unit tests but is relatively new for integration tests:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;UserType &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;GUEST&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, LOGGED_IN, PREMIUM, BUSINESS }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;PaymentMethod &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;CARD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, PAYPAL, APPLE_PAY, GIFT_CARD, BANK_TRANSFER }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Random&lt;&#x2F;span&gt;&lt;span&gt; rand = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Random&lt;&#x2F;span&gt;&lt;span&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; random seed
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;UserType&lt;&#x2F;span&gt;&lt;span&gt; user = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pickRandom&lt;&#x2F;span&gt;&lt;span&gt;(rand, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;UserType&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;values&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;PaymentMethod&lt;&#x2F;span&gt;&lt;span&gt; paymentMethod = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pickRandom&lt;&#x2F;span&gt;&lt;span&gt;(rand, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;PaymentMethod&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;values&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rather than hardcoding test cases like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;assertFalse&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;User&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GUEST&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;canUse&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SAVED_CARD&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can write property-based assertions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;assertEquals&lt;&#x2F;span&gt;&lt;span&gt;(user.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isAuthenticated&lt;&#x2F;span&gt;&lt;span&gt;(), user.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;canUse&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SAVED_CARD&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This approach is implemented in libraries like:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Python: &lt;strong&gt;Hypothesis&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Java: &lt;strong&gt;jqwik&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Rust: &lt;strong&gt;proptest&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;simulating-the-world-injecting-chaos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simulating-the-world-injecting-chaos&quot; aria-label=&quot;Anchor link for: simulating-the-world-injecting-chaos&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Simulating the World: Injecting Chaos&lt;&#x2F;h3&gt;
&lt;p&gt;We also need to simulate the chaotic nature of production environments by injecting failures into:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Time (delays, timeouts, retries, race conditions)&lt;&#x2F;li&gt;
&lt;li&gt;Network (latency, failure, disconnection)&lt;&#x2F;li&gt;
&lt;li&gt;Infrastructure (disk full, service crash, replica lag)&lt;&#x2F;li&gt;
&lt;li&gt;External dependencies (slow APIs, rate limiting)&lt;&#x2F;li&gt;
&lt;li&gt;Load (varying numbers of concurrent users)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;It&#x27;s important to note that implementing full deterministic simulation requires control over every aspect of your system, from task scheduling to I&#x2F;O operations. This is significantly easier if your system is built with simulation in mind from day one. Some languages offer advantages in this areaâ€”for example, Rust&#x27;s ecosystem makes it relatively straightforward to implement custom virtual threading executors compared to modifying the JVM.&lt;&#x2F;p&gt;
&lt;p&gt;For existing codebases where a full rewrite isn&#x27;t practical, you can still benefit from simulation testing by adding layers of indirection. Even simple mocks like the HTTP client example below can help you discover how your system behaves under various failure conditions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;HttpClientMock &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private final &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Random &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;random &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Random&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; random seed
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;url&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Simulate random chance of returning an error
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(random.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nextDouble&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0.2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;HTTP 500 Internal Server Error&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; delay &lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; random.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;nextInt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;500&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Simulate 0â€“499ms latency
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Thread&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;sleep&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(delay);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;HTTP 200 OK&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;who-uses-dst&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#who-uses-dst&quot; aria-label=&quot;Anchor link for: who-uses-dst&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Who Uses DST?&lt;&#x2F;h2&gt;
&lt;p&gt;Not many companies are using DST, but we are starting to have a nice list:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Clever Cloud&lt;&#x2F;li&gt;
&lt;li&gt;TigerBeetle&lt;&#x2F;li&gt;
&lt;li&gt;Resonate&lt;&#x2F;li&gt;
&lt;li&gt;RisingWave&lt;&#x2F;li&gt;
&lt;li&gt;Sync @ Dropbox&lt;&#x2F;li&gt;
&lt;li&gt;sled.rs&lt;&#x2F;li&gt;
&lt;li&gt;Kafkaâ€™s KRaft&lt;&#x2F;li&gt;
&lt;li&gt;Astradot&lt;&#x2F;li&gt;
&lt;li&gt;Polar Signals&lt;&#x2F;li&gt;
&lt;li&gt;AWS&lt;&#x2F;li&gt;
&lt;li&gt;Antithesis&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;dst-at-clever-cloud&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dst-at-clever-cloud&quot; aria-label=&quot;Anchor link for: dst-at-clever-cloud&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;DST at Clever Cloud&lt;&#x2F;h3&gt;
&lt;p&gt;At Clever Cloud, we&#x27;re implementing a multi-tenant, multi-model distributed database heavily relying on FoundationDB. While we haven&#x27;t developed our own deterministic simulation testing framework yet, we leverage &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.foundationdb.org&#x2F;&quot;&gt;FoundationDB&lt;&#x2F;a&gt;&#x27;s built-in simulation by injecting custom workloads.&lt;&#x2F;strong&gt; This approach is core to developing our first serverless product, &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;blog&#x2F;features&#x2F;2024&#x2F;06&#x2F;11&#x2F;materia-kv-our-easy-to-use-serverless-key-value-database-is-available-to-all&#x2F;&quot;&gt;Materia KV&lt;&#x2F;a&gt;. The simulations FoundationDB provides include:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Random network partitions&lt;&#x2F;li&gt;
&lt;li&gt;Machine reboots&lt;&#x2F;li&gt;
&lt;li&gt;Concurrent chaos events, like shuffling the actual data disk between 2 nodes&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Our simulation-driven development workflow runs simulations:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;In CI loops&lt;&#x2F;li&gt;
&lt;li&gt;Continuously in the cloud&lt;&#x2F;li&gt;
&lt;li&gt;With 30 minutes of simulation equating to roughly 24 hours of chaos testing&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;When we find a faulty seed, we can replay it locally, providing a superpower for debugging complex distributed systems issues.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;benefits-for-developer-education&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#benefits-for-developer-education&quot; aria-label=&quot;Anchor link for: benefits-for-developer-education&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Benefits for Developer Education&lt;&#x2F;h3&gt;
&lt;p&gt;Deterministic simulation testing doesn&#x27;t just help find bugsâ€”it helps developers grow. By working with simulated but realistic failure scenarios, developers build intuition for how distributed systems behave under stress without having to experience painful on-call incidents.&lt;&#x2F;p&gt;
&lt;p&gt;Moreover, deterministic simulation testing has instilled a &lt;strong&gt;deep trust in our software&lt;&#x2F;strong&gt;, as it is tested under conditions even more challenging than those encountered in production. This confidence has been crucial for us.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;The gap between development and production is real and significant. Traditional testing approaches can&#x27;t scale to cover all the possible combinations of user behavior and world events that our systems will encounter.&lt;&#x2F;p&gt;
&lt;p&gt;Deterministic simulation testing offers a powerful alternative that allows us to test complex distributed systems more thoroughly, find bugs before they impact users, and train developers to build more resilient systems.&lt;&#x2F;p&gt;
&lt;p&gt;By embracing simulation-driven development, we can build software that better handles the chaotic reality of production environmentsâ€”and maybe reduce those 3 AM pages that give engineers like me unfortunate nicknames.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Want to learn more? Check out my &lt;a href=&quot;&#x2F;posts&#x2F;learn-about-dst&#x2F;&quot;&gt;curated list of resources on deterministic simulation testing&lt;&#x2F;a&gt;, which includes articles, talks, and implementation examples.&lt;&#x2F;p&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your experiences with simulation testing. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>So, You Want to Learn More About Deterministic Simulation Testing?</title>
        <published>2025-04-11T00:00:00+02:00</published>
        <updated>2025-04-11T00:00:00+02:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/learn-about-dst/"/>
        <id>https://pierrezemb.fr/posts/learn-about-dst/</id>
        
        <category term="distributed" schema="https://pierrezemb.fr/tags/" label="distributed"/>
        <category term="testing" schema="https://pierrezemb.fr/tags/" label="testing"/>
        <category term="reliability" schema="https://pierrezemb.fr/tags/" label="reliability"/>
        <category term="simulation" schema="https://pierrezemb.fr/tags/" label="simulation"/>
        <category term="deterministic" schema="https://pierrezemb.fr/tags/" label="deterministic"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/learn-about-dst/">&lt;p&gt;I recently attended &lt;a href=&quot;https:&#x2F;&#x2F;bugbash.antithesis.com&#x2F;&quot;&gt;BugBash 2025&lt;&#x2F;a&gt;, a software reliability conference organized by &lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&quot;&gt;Antithesis&lt;&#x2F;a&gt; in Washington, D.C. during April 3-4, 2025. The conference brought together industry experts like Kyle Kingsbury, Ankush Desai, and Mitchell Hashimoto to discuss various aspects of building reliable software, with deterministic simulation testing being a significant focus throughout many of the sessions and discussions.&lt;&#x2F;p&gt;
&lt;p&gt;One of the highlights for me was having the chance to talk with the Antithesis team and meet some of the original creators of FoundationDB.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-deterministic-simulation-testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-deterministic-simulation-testing&quot; aria-label=&quot;Anchor link for: what-is-deterministic-simulation-testing&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;What is Deterministic Simulation Testing?&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; For a deeper dive into this concept and its practical applications, check out my article on &lt;a href=&quot;&#x2F;posts&#x2F;simulation-driven-development&#x2F;&quot;&gt;What if we embraced simulation-driven development?&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The best description of DST I&#x27;ve found is described in &lt;a href=&quot;https:&#x2F;&#x2F;apple.github.io&#x2F;foundationdb&#x2F;testing.html&quot;&gt;FoundationDB&#x27;s testing page&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The major goal of Simulation is to make sure that we find and diagnose issues in simulation rather than the real world. Simulation runs tens of thousands of simulations every night, each one simulating large numbers of component failures. Based on the volume of tests that we run and the increased intensity of the failures in our scenarios, we estimate that we have run the equivalent of roughly one trillion CPU-hours of simulation on FoundationDB.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Simulation is able to conduct a deterministic simulation of an entire FoundationDB cluster within a single-threaded process. Determinism is crucial in that it allows perfect repeatability of a simulated run, facilitating controlled experiments to home in on issues. The simulation steps through time, synchronized across the system, representing a larger amount of real time in a smaller amount of simulated time. In practice, our simulations usually have about a 10-1 factor of real-to-simulated time, which is advantageous for the efficiency of testing.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;We use Simulation to simulate failures modes at the network, machine, and datacenter levels, including connection failures, degradation of machine performance, machine shutdowns or reboots, machines coming back from the dead, etc. We stress-test all of these failure modes, failing machines at very short intervals, inducing unusually severe loads, and delaying communications channels.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Simulation&#x27;s success has surpassed our expectation and has been vital to our engineering team. It seems unlikely that we would have been able to build FoundationDB without this technology.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;After years of operating many Apache-oriented distributed systems, I can confidently say that FoundationDB stands apart in its remarkable robustnessâ€”I&#x27;ve rarely been paged for it, which speaks volumes about its stability in production. At &lt;a href=&quot;https:&#x2F;&#x2F;www.clever-cloud.com&#x2F;&quot;&gt;Clever Cloud&lt;&#x2F;a&gt;, we&#x27;ve even leveraged FoundationDB&#x27;s simulation framework during our application development by &lt;a href=&quot;&#x2F;posts&#x2F;providing-safety-fdb-rs&#x2F;#user-safety&quot;&gt;embedding Rust code inside FDB&#x27;s simulation environment&lt;&#x2F;a&gt;, allowing us to inherit the same reliability guarantees for our custom applications.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr&quot; aria-label=&quot;Anchor link for: tl-dr&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;TL;DR&lt;&#x2F;h2&gt;
&lt;p&gt;If you only have limited time, here are the four must-watch videos that will give you the best introduction to deterministic simulation testing:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4fFDFbi3toc&quot;&gt;Will Wilson: Testing Distributed Systems with Deterministic Simulation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=fFSPwJFXVlw&quot;&gt;Will Wilson: Autonomous Testing and the Future of Software Development&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=m3HwXlQPCEU&quot;&gt;Will Wilson: Testing a Single-Node, Single Threaded, Distributed System Written in 1985&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=eZ1mmqlq-mY&quot;&gt;Will Wilson: Let&#x27;s all write good software&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;(Yes, it seems Will Wilson has a monopoly on great introductory talks on the topic. Having had the chance to meet him, I can personally vouch that he is not a deterministic algorithm for generating insightful presentations, though the sheer quality of his talks might make you wonder.)&lt;&#x2F;p&gt;
&lt;p&gt;A curated feed of recent articles and blog posts about DST can be found at &lt;a href=&quot;https:&#x2F;&#x2F;deterministic-simulation-testing.github.io&#x2F;planet-dst&#x2F;&quot;&gt;Planet DST&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;essential-reading&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#essential-reading&quot; aria-label=&quot;Anchor link for: essential-reading&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Essential Reading&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;foundations-concepts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#foundations-concepts&quot; aria-label=&quot;Anchor link for: foundations-concepts&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Foundations &amp;amp; Concepts&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.cockroachlabs.com&#x2F;blog&#x2F;demonic-nondeterminism&#x2F;&quot;&gt;CockroachLabs: Demonic Nondeterminism&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;transactional.blog&#x2F;simulation&#x2F;buggify&quot;&gt;Alex Miller: BUGGIFY&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.tigerbeetle.com&#x2F;concepts&#x2F;safety&#x2F;#software-reliability&quot;&gt;TigerBeetle: Building Reliable Systems&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;journal.resonatehq.io&#x2F;p&#x2F;deterministic-simulation-testing&quot;&gt;Dominik Tornow: Deterministic Simulation Testing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;poorlydefinedbehaviour.github.io&#x2F;posts&#x2F;deterministic_simulation_testing&#x2F;&quot;&gt;Poorly Defined Behaviour: Deterministic Simulation Testing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;notes.eatonphil.com&#x2F;2024-08-20-deterministic-simulation-testing.html&quot;&gt;Phil Eaton: What&#x27;s the big deal about Deterministic Simulation Testing?&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;queue.acm.org&#x2F;detail.cfm?ref=rss&amp;amp;id=3712057&quot;&gt;AWS: Systems Correctness Practices&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;language-specific-implementations&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#language-specific-implementations&quot; aria-label=&quot;Anchor link for: language-specific-implementations&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Language-Specific Implementations&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;turmoil&#x2F;latest&#x2F;turmoil&#x2F;&quot;&gt;Turmoil: Network Simulation Framework for Rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;madsim&#x2F;latest&#x2F;madsim&#x2F;&quot;&gt;MadSim: Deterministic Simulation Testing Library for Rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;sled.rs&#x2F;simulation.html&quot;&gt;Sled: Simulation Testing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;s2.dev&#x2F;blog&#x2F;dst&quot;&gt;S2: Deterministic simulation testing for async Rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.polarsignals.com&#x2F;blog&#x2F;posts&#x2F;2024&#x2F;05&#x2F;28&#x2F;mostly-dst-in-go&quot;&gt;Polar Signals: Mostly-DST in Go&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;real-world-case-studies&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#real-world-case-studies&quot; aria-label=&quot;Anchor link for: real-world-case-studies&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Real-World Case Studies&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tigerbeetle.com&#x2F;blog&#x2F;2022-11-23-a-friendly-abstraction-over-iouring-and-kqueue&#x2F;&quot;&gt;TigerBeetle: A Friendly Abstraction Over io_uring and kqueue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;dropbox.tech&#x2F;infrastructure&#x2F;-testing-our-new-sync-engine&quot;&gt;Dropbox: Testing Our New Sync Engine&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tigerbeetle.com&#x2F;blog&#x2F;2023-07-11-we-put-a-distributed-database-in-the-browser&#x2F;&quot;&gt;TigerBeetle: We Put a Distributed Database in the Browser&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&#x2F;solutions&#x2F;case_studies&#x2F;&quot;&gt;Antithesis: Case Studies&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;risingwave.com&#x2F;blog&#x2F;deterministic-simulation-a-new-era-of-distributed-system-testing&#x2F;&quot;&gt;RisingWave: A New Era of Distributed System Testing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;risingwave.com&#x2F;blog&#x2F;applying-deterministic-simulation-the-risingwave-story-part-2-of-2&#x2F;&quot;&gt;RisingWave: The RisingWave Story&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.warpstream.com&#x2F;blog&#x2F;deterministic-simulation-testing-for-our-entire-saas&quot;&gt;WarpStream: DST for Our Entire SaaS&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;antithesis.com&#x2F;blog&#x2F;sdtalk&#x2F;&quot;&gt;Antithesis: How Antithesis finds bugs (with help from the Super Mario Bros.)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;talks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#talks&quot; aria-label=&quot;Anchor link for: talks&quot;&gt;ðŸ”—&lt;&#x2F;a&gt;Talks&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IaB8jvjW0kk&quot;&gt;Ben Collins: FoundationDB Testing: Past &amp;amp; Present&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rvHd4Y76-fs&quot;&gt;Marc Brooker: AWS re:Invent 2024 - Try again: The tools and techniques behind resilient systems (ARC403)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=6y8Ga3oogLY&quot;&gt;TigerBeetle: Episode 064: Two In One, New Request Protocol and VOPR Tutorial&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;fosdem.org&#x2F;2025&#x2F;schedule&#x2F;event&#x2F;fosdem-2025-4279-squashing-the-heisenbug-with-deterministic-simulation-testing&#x2F;&quot;&gt;FOSDEM 2025: Squashing the Heisenbug with Deterministic Simulation Testing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=024c8OwR4JM&quot;&gt;BugBash 2025: Lawrie Green - How to succeed in software testing without really trying&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Have I missed any important resources on Deterministic Simulation Testing? This field is rapidly evolving, and I&#x27;m always looking to expand this collection. If you know of any articles, talks, or tools related to DST that should be included here, please reach out! I&#x27;d love to hear about your experiences with deterministic testing as well.&lt;&#x2F;p&gt;
&lt;p&gt;Please, feel free to react to this article, you can reach me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, or have a look on my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
