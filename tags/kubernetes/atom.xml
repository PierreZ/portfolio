<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Pierre Zemb&#x27;s Blog - kubernetes</title>
    <subtitle>Pierre Zemb personal blog</subtitle>
    <link rel="self" type="application/atom+xml" href="https://pierrezemb.fr/tags/kubernetes/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://pierrezemb.fr"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-11-12T00:00:00+00:00</updated>
    <id>https://pierrezemb.fr/tags/kubernetes/atom.xml</id>
    <entry xml:lang="en">
        <title>Diving into Kubernetes&#x27; Watch Cache</title>
        <published>2025-11-12T00:00:00+00:00</published>
        <updated>2025-11-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Pierre Zemb
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://pierrezemb.fr/posts/diving-into-kubernetes-watch-cache/"/>
        <id>https://pierrezemb.fr/posts/diving-into-kubernetes-watch-cache/</id>
        
        <category term="diving-into" schema="https://pierrezemb.fr/tags/" label="diving-into"/>
        <category term="kubernetes" schema="https://pierrezemb.fr/tags/" label="kubernetes"/>
        <category term="distributed-systems" schema="https://pierrezemb.fr/tags/" label="distributed-systems"/>
        <category term="etcd" schema="https://pierrezemb.fr/tags/" label="etcd"/>
        <category term="caching" schema="https://pierrezemb.fr/tags/" label="caching"/>
        <content type="html" xml:base="https://pierrezemb.fr/posts/diving-into-kubernetes-watch-cache/">&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;a href=&quot;&#x2F;tags&#x2F;diving-into&#x2F;&quot;&gt;Diving Into&lt;&#x2F;a&gt; is a blogpost series where we dig into specific parts of a project&#x27;s codebase. In this episode, we dig into Kubernetes&#x27; watch cache implementation.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;While debugging an etcd-shim on FoundationDB, I kept hitting &lt;code&gt;&quot;Timeout: Too large resource version&quot;&lt;&#x2F;code&gt; errors. The cache was stuck at revision 3044, but clients requested 3047. Three seconds later: timeout. This led me into the watch cache internals: specifically the 3-second timeout in &lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt; and how progress notifications solve the problem. Let&#x27;s dig into how it actually works.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; Yes, &lt;a href=&quot;https:&#x2F;&#x2F;clever.cloud&quot;&gt;Clever Cloud&lt;&#x2F;a&gt; runs an etcd-shim on top of FoundationDB for Kubernetes. Truth is, we&#x27;re not alone: &lt;a href=&quot;https:&#x2F;&#x2F;aws.amazon.com&#x2F;blogs&#x2F;containers&#x2F;under-the-hood-amazon-eks-ultra-scale-clusters&#x2F;&quot;&gt;AWS&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;cloud.google.com&#x2F;blog&#x2F;products&#x2F;containers-kubernetes&#x2F;gke-65k-nodes-and-counting?hl=en&quot;&gt;GKE&lt;&#x2F;a&gt; have custom storage layers too. After &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=IrJyrGQ_R9c&quot;&gt;operating etcd at OVHcloud&lt;&#x2F;a&gt;, we chose a different path. I actually wrote a naive PoC during COVID (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;PierreZ&#x2F;fdb-etcd&quot;&gt;fdb-etcd&lt;&#x2F;a&gt;) without testing it against a real apiserver üòÖ it was mostly an excuse to discover &lt;a href=&quot;https:&#x2F;&#x2F;pierrez.github.io&#x2F;fdb-book&#x2F;the-record-layer&#x2F;what-is-record-layer.html&quot;&gt;the Record-Layer&lt;&#x2F;a&gt;. You can read more about the technical challenges in &lt;a href=&quot;https:&#x2F;&#x2F;forums.foundationdb.org&#x2F;t&#x2F;a-foundationdb-layer-for-apiserver-as-an-alternative-to-etcd&#x2F;2697&quot;&gt;this FoundationDB forum discussion&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;overview-of-the-watch-cache&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview-of-the-watch-cache&quot; aria-label=&quot;Anchor link for: overview-of-the-watch-cache&quot;&gt;üîó&lt;&#x2F;a&gt;Overview of the Watch Cache&lt;&#x2F;h2&gt;
&lt;p&gt;When I first looked at the watch cache implementation, I expected a single monolithic cache sitting between the apiserver and etcd. It took compiling my own apiserver with additional logging to realize the architecture is more interesting: &lt;strong&gt;each resource type gets its own independent Cacher instance&lt;&#x2F;strong&gt;. Pods have one. Services have another. Deployments get their own. Every resource group runs an isolated LIST+WATCH loop, maintaining its own in-memory cache.&lt;&#x2F;p&gt;
&lt;p&gt;As the &lt;a href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;blog&#x2F;2024&#x2F;08&#x2F;15&#x2F;consistent-read-from-cache-beta&#x2F;&quot;&gt;Kubernetes 1.34 blog post&lt;&#x2F;a&gt; explains, this enhancement allows the API server to serve consistent read requests directly from the watch cache, significantly reducing the load on etcd and improving overall cluster performance.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;architecture&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#architecture&quot; aria-label=&quot;Anchor link for: architecture&quot;&gt;üîó&lt;&#x2F;a&gt;Architecture&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Client Requests (kubectl, controllers)
&lt;&#x2F;span&gt;&lt;span&gt;          ‚Üì
&lt;&#x2F;span&gt;&lt;span&gt;    Cacher (per resource)
&lt;&#x2F;span&gt;&lt;span&gt;          ‚Üì In-memory watch cache
&lt;&#x2F;span&gt;&lt;span&gt;          ‚Üì (on cache miss&#x2F;delegate)
&lt;&#x2F;span&gt;&lt;span&gt;    etcd3&#x2F;Store
&lt;&#x2F;span&gt;&lt;span&gt;          ‚Üì
&lt;&#x2F;span&gt;&lt;span&gt;    etcd &#x2F; etcd-shim
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The main components:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;cacher.go&quot;&gt;cacher.go&lt;&#x2F;a&gt; - The in-memory watch cache&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;etcd3&#x2F;store.go&quot;&gt;store.go&lt;&#x2F;a&gt; - Direct &lt;a href=&quot;&#x2F;posts&#x2F;notes-about-etcd&#x2F;&quot;&gt;etcd&lt;&#x2F;a&gt; communication layer&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;how-the-cache-gets-fed&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-the-cache-gets-fed&quot; aria-label=&quot;Anchor link for: how-the-cache-gets-fed&quot;&gt;üîó&lt;&#x2F;a&gt;How The Cache Gets Fed&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;initialization-the-list-phase&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#initialization-the-list-phase&quot; aria-label=&quot;Anchor link for: initialization-the-list-phase&quot;&gt;üîó&lt;&#x2F;a&gt;Initialization: The LIST Phase&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Nothing works until the cache initializes&lt;&#x2F;strong&gt;. When a Cacher starts, every read for that resource blocks until initialization completes. This matters because initialization isn&#x27;t instant: it&#x27;s a paginated LIST operation fetching 10,000 items per page. For a large cluster with thousands of pods, this takes time.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the sequence: The Reflector pattern kicks off with a complete LIST operation. Each resource cache fetches all existing objects through paginated requests. Once the LIST completes, &lt;code&gt;watchCache.Replace()&lt;&#x2F;code&gt; populates the in-memory cache with these objects. The &lt;strong&gt;critical moment&lt;&#x2F;strong&gt; happens when the &lt;code&gt;SetOnReplace()&lt;&#x2F;code&gt; callback fires (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;cacher.go#L468-L478&quot;&gt;cacher.go:468-478&lt;&#x2F;a&gt;), marking the cache as READY. Until that callback fires, every request for that resource waits.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;continuous-sync-the-watch-phase&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#continuous-sync-the-watch-phase&quot; aria-label=&quot;Anchor link for: continuous-sync-the-watch-phase&quot;&gt;üîó&lt;&#x2F;a&gt;Continuous Sync: The WATCH Phase&lt;&#x2F;h3&gt;
&lt;p&gt;After initialization, the real trick begins: the cache maintains synchronization through a Watch stream that starts at LIST revision + 1. This &lt;strong&gt;guarantees no events are missed&lt;&#x2F;strong&gt; between the LIST and WATCH operations. The watch picks up exactly where the list left off. Events flow from etcd through a buffered channel (capacity: 100 events) and are processed by the &lt;code&gt;dispatchEvents()&lt;&#x2F;code&gt; goroutine, which runs continuously, matching events to interested watchers.&lt;&#x2F;p&gt;
&lt;p&gt;This pattern depends on continuous event flow. When events stop arriving, when resources go quiet, that&#x27;s when progress notifications become essential. See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;client-go&#x2F;tools&#x2F;cache&#x2F;reflector.go&quot;&gt;Reflector documentation&lt;&#x2F;a&gt; for the complete pattern.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-problem-timeout-too-large-resource-version&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-problem-timeout-too-large-resource-version&quot; aria-label=&quot;Anchor link for: the-problem-timeout-too-large-resource-version&quot;&gt;üîó&lt;&#x2F;a&gt;The Problem: &quot;Timeout: Too large resource version&quot;&lt;&#x2F;h2&gt;
&lt;p&gt;While debugging our etcd-shim, we kept hitting this error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Error getting keys: err=&amp;quot;Timeout: Too large resource version: 3047, current: 3044&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A client was requesting ResourceVersion 3047, but the cache only knew about revision 3044. The cache would wait... and timeout after 3 seconds.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;understanding-cache-freshness&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#understanding-cache-freshness&quot; aria-label=&quot;Anchor link for: understanding-cache-freshness&quot;&gt;üîó&lt;&#x2F;a&gt;Understanding Cache Freshness&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-freshness-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-freshness-check&quot; aria-label=&quot;Anchor link for: the-freshness-check&quot;&gt;üîó&lt;&#x2F;a&gt;The Freshness Check&lt;&#x2F;h3&gt;
&lt;p&gt;When a client requests a consistent read at a specific ResourceVersion, Kubernetes needs to ensure the cache is &quot;fresh enough&quot; to serve that request. Here&#x27;s the check: is my current revision at least as high as the requested revision? If not, it calls &lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt; with a 3-second timeout, waiting for Watch events to bring the cache up to date.&lt;&#x2F;p&gt;
&lt;p&gt;From &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;cacher.go#L1257-L1261&quot;&gt;cacher.go:1257-1261&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watchCache&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;notFresh&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requestedWatchRV&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watchCache&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;waitingUntilFresh&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Add&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watchCache&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;waitingUntilFresh&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Remove&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;err &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watchCache&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;waitUntilFreshAndBlock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requestedWatchRV&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The actual timeout implementation (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;watch_cache.go#L448-L488&quot;&gt;watch_cache.go:448-488&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;watchCache&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;waitUntilFreshAndBlock&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx context&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Context&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;uint64&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;error &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;startTime &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clock&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Now&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;defer func&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metrics&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WatchCacheReadWait&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WithContext&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WithLabelValues&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;groupResource&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Group&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;groupResource&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Resource&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Observe&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clock&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Since&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;startTime&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Seconds&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; In case resourceVersion is 0, we accept arbitrarily stale result.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; As a result, the condition in the below for loop will never be
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; satisfied (w.resourceVersion is never negative), this call will
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; never hit the w.cond.Wait().
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; As a result - we can optimize the code by not firing the wakeup
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; function (and avoid starting a gorotuine), especially given that
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; resourceVersion=0 is the most common case.
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;go func&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Wake us up when the time limit has expired.  The docs
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; promise that time.After (well, NewTimer, which it calls)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; will wait *at least* the duration given. Since this go
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; routine starts sometime after we record the start time, and
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; it will wake up the loop below sometime after the broadcast,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; we don&amp;#39;t need to worry about waking it up before the time
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; has expired accidentally.
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;lt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clock&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;After&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;blockTimeout&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cond&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Broadcast&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;        }()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RLock&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;span &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tracing&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SpanFromContext&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;span&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AddEvent&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;watchCache locked acquired&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;clock&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Since&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;startTime&lt;&#x2F;span&gt;&lt;span&gt;) &amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;blockTimeout &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Request that the client retry after &amp;#39;resourceVersionTooHighRetrySeconds&amp;#39; seconds.
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;storage&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NewTooLargeResourceVersionError&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersion&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;resourceVersionTooHighRetrySeconds&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cond&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Wait&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;span&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AddEvent&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;watchCache fresh enough&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the cache can&#x27;t catch up within those 3 seconds, the request times out.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;ve ever seen kubectl commands hang for exactly 3 seconds before returning data, this is why. The cache is waiting for events that will never come.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-problem-with-quiet-resources&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-problem-with-quiet-resources&quot; aria-label=&quot;Anchor link for: the-problem-with-quiet-resources&quot;&gt;üîó&lt;&#x2F;a&gt;The Problem with Quiet Resources&lt;&#x2F;h3&gt;
&lt;p&gt;This is where things get tricky. For infrequently-updated resources (namespaces, configmaps, etc.):&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Time&lt;&#x2F;th&gt;&lt;th&gt;Component&lt;&#x2F;th&gt;&lt;th&gt;Event&lt;&#x2F;th&gt;&lt;th&gt;Cache RV&lt;&#x2F;th&gt;&lt;th&gt;etcd RV&lt;&#x2F;th&gt;&lt;th&gt;Notes&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;T0&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;Idle, no changes&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;No namespace changes for 5 minutes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T1&lt;&#x2F;td&gt;&lt;td&gt;Pod&#x2F;Service caches&lt;&#x2F;td&gt;&lt;td&gt;Resources changing&lt;&#x2F;td&gt;&lt;td&gt;-&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Global etcd revision advances&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T2&lt;&#x2F;td&gt;&lt;td&gt;Namespace watch&lt;&#x2F;td&gt;&lt;td&gt;Receives nothing&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;No namespace events to process&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T3&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;Still waiting&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Cache stuck, unaware of global progress&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T4&lt;&#x2F;td&gt;&lt;td&gt;Client&lt;&#x2F;td&gt;&lt;td&gt;Lists pods successfully&lt;&#x2F;td&gt;&lt;td&gt;-&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Response includes current RV 3047&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T5&lt;&#x2F;td&gt;&lt;td&gt;Client&lt;&#x2F;td&gt;&lt;td&gt;Requests namespace read at RV ‚â• 3047&lt;&#x2F;td&gt;&lt;td&gt;-&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Consistent read requirement&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T6&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;&quot;I&#x27;m at 3044, need 3047... waiting&quot;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T7&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;Timeout!&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;3 seconds elapsed, returns error&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The cache has no way to know if etcd has moved forward. Is the system healthy? Is something broken? It just sees... nothing.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;timeout-behavior-summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#timeout-behavior-summary&quot; aria-label=&quot;Anchor link for: timeout-behavior-summary&quot;&gt;üîó&lt;&#x2F;a&gt;Timeout Behavior Summary&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Scenario&lt;&#x2F;th&gt;&lt;th&gt;Cache RV&lt;&#x2F;th&gt;&lt;th&gt;Requested RV&lt;&#x2F;th&gt;&lt;th&gt;Result&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Fresh cache&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;3045&lt;&#x2F;td&gt;&lt;td&gt;‚úì Serve immediately&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Stale cache&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;‚è± Wait 3s ‚Üí timeout&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;With progress&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;‚úì RequestProgress ‚Üí serve&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;progress-notifications-keeping-quiet-resources-fresh&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#progress-notifications-keeping-quiet-resources-fresh&quot; aria-label=&quot;Anchor link for: progress-notifications-keeping-quiet-resources-fresh&quot;&gt;üîó&lt;&#x2F;a&gt;Progress Notifications: Keeping Quiet Resources Fresh&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;what-are-progress-notifications&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-are-progress-notifications&quot; aria-label=&quot;Anchor link for: what-are-progress-notifications&quot;&gt;üîó&lt;&#x2F;a&gt;What Are Progress Notifications?&lt;&#x2F;h3&gt;
&lt;p&gt;Here&#x27;s the trick: progress notifications are &lt;strong&gt;empty Watch responses&lt;&#x2F;strong&gt; that only update the revision:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WatchResponse &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Header&lt;&#x2F;span&gt;&lt;span&gt;: { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Revision&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3047 &lt;&#x2F;span&gt;&lt;span&gt;},  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Current etcd revision
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Events&lt;&#x2F;span&gt;&lt;span&gt;: []                     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; No actual data changes
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;They solve the quiet resource problem by telling the cache: &quot;etcd is now at revision X, even though your resource hasn&#x27;t changed.&quot;&lt;&#x2F;p&gt;
&lt;p&gt;This is exactly what we had forgotten to implement in our etcd-shim. We handled regular Watch events perfectly, but didn&#x27;t support progress notifications. The result? Kubernetes&#x27; watch cache would timeout waiting for revisions that would never arrive through normal events. Once we added &lt;code&gt;RequestProgress&lt;&#x2F;code&gt; support and started sending these empty bookmark responses, the timeouts disappeared.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;two-mechanisms&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#two-mechanisms&quot; aria-label=&quot;Anchor link for: two-mechanisms&quot;&gt;üîó&lt;&#x2F;a&gt;Two Mechanisms&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;1-on-demand-requestwatchprogress&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-on-demand-requestwatchprogress&quot; aria-label=&quot;Anchor link for: 1-on-demand-requestwatchprogress&quot;&gt;üîó&lt;&#x2F;a&gt;1. On-Demand: RequestWatchProgress()&lt;&#x2F;h4&gt;
&lt;p&gt;When the cache needs to catch up, it can explicitly request a progress notification. See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;etcd3&#x2F;store.go#L99-L103&quot;&gt;store.go:99-103&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;store&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;RequestWatchProgress&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx context&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Context&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;error &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;client&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RequestProgress&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watchContext&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When called, etcd responds with a bookmark (also called a progress notification) containing the current revision. The cache at revision 3044 calls &lt;code&gt;RequestProgress()&lt;&#x2F;code&gt;, receives &lt;code&gt;{ Revision: 3047, Events: [] }&lt;&#x2F;code&gt;, and immediately updates its internal state to 3047.&lt;&#x2F;p&gt;
&lt;p&gt;The progress notification is detected in the watch stream (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;etcd3&#x2F;watcher.go#L401-L404&quot;&gt;watcher.go:401-404&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Handle progress notifications (bookmarks)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wres&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IsProgressNotify&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wc&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;queueEvent&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progressNotifyEvent&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wres&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Header&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;GetRevision&lt;&#x2F;span&gt;&lt;span&gt;()))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metrics&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RecordEtcdBookmark&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;wc&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;watcher&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;groupResource&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;continue
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;2-proactive-periodic-progress-requests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-proactive-periodic-progress-requests&quot; aria-label=&quot;Anchor link for: 2-proactive-periodic-progress-requests&quot;&gt;üîó&lt;&#x2F;a&gt;2. Proactive: Periodic Progress Requests&lt;&#x2F;h4&gt;
&lt;p&gt;Kubernetes also runs a background component called &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;cacher.go#L425-L428&quot;&gt;progressRequester&lt;&#x2F;a&gt; that monitors quiet watches. This component detects when watches haven&#x27;t received events for a while and periodically calls &lt;code&gt;RequestProgress()&lt;&#x2F;code&gt; to ensure even completely idle resources stay fresh. This proactive approach prevents timeout errors before they happen.&lt;&#x2F;p&gt;
&lt;p&gt;The progress requester is initialized when the Cacher is created (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;kubernetes&#x2F;blob&#x2F;release-1.34&#x2F;staging&#x2F;src&#x2F;k8s.io&#x2F;apiserver&#x2F;pkg&#x2F;storage&#x2F;cacher&#x2F;cacher.go#L425-L428&quot;&gt;cacher.go:425-428&lt;&#x2F;a&gt;):&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progressRequester &lt;&#x2F;span&gt;&lt;span&gt;:= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;progress&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NewConditionalProgressRequester&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Storage&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RequestWatchProgress&lt;&#x2F;span&gt;&lt;span&gt;,  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The function to call
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Clock&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;contextMetadata
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-complete-flow&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-complete-flow&quot; aria-label=&quot;Anchor link for: the-complete-flow&quot;&gt;üîó&lt;&#x2F;a&gt;The Complete Flow&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Timeline showing how progress notifications solve the timeout:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Time&lt;&#x2F;th&gt;&lt;th&gt;Component&lt;&#x2F;th&gt;&lt;th&gt;Action&lt;&#x2F;th&gt;&lt;th&gt;Cache RV&lt;&#x2F;th&gt;&lt;th&gt;etcd RV&lt;&#x2F;th&gt;&lt;th&gt;Details&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;T0&lt;&#x2F;td&gt;&lt;td&gt;Namespace watch&lt;&#x2F;td&gt;&lt;td&gt;Established&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;No namespace changes happening&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T1&lt;&#x2F;td&gt;&lt;td&gt;Pod resources&lt;&#x2F;td&gt;&lt;td&gt;Creates&#x2F;updates&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Namespace watch: silent, cache stuck at 3044&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T2&lt;&#x2F;td&gt;&lt;td&gt;Client&lt;&#x2F;td&gt;&lt;td&gt;Requests namespace LIST at RV 3047&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;notFresh(3047)&lt;&#x2F;code&gt; ‚Üí true, starts &lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T3&lt;&#x2F;td&gt;&lt;td&gt;progressRequester&lt;&#x2F;td&gt;&lt;td&gt;Detects quiet watch&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Calls &lt;code&gt;RequestProgress()&lt;&#x2F;code&gt; on namespace watch stream&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T4&lt;&#x2F;td&gt;&lt;td&gt;etcd&lt;&#x2F;td&gt;&lt;td&gt;Sends progress notification&lt;&#x2F;td&gt;&lt;td&gt;3044&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;WatchResponse { Header: { Revision: 3047 }, Events: [] }&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T5&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;Processes bookmark&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;Updates internal revision 3044 ‚Üí 3047, signals waiters&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;T6&lt;&#x2F;td&gt;&lt;td&gt;Namespace cache&lt;&#x2F;td&gt;&lt;td&gt;Returns successfully&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;3047&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt; completes, request served from cache&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;key-takeaways&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#key-takeaways&quot; aria-label=&quot;Anchor link for: key-takeaways&quot;&gt;üîó&lt;&#x2F;a&gt;Key Takeaways&lt;&#x2F;h2&gt;
&lt;p&gt;Here&#x27;s what you need to know: Kubernetes runs a separate watch cache for each resource type (pods, services, deployments, etc.), and each one maintains its own LIST+WATCH loop. When you request a consistent read, the cache performs a freshness check with a &lt;strong&gt;3-second timeout&lt;&#x2F;strong&gt; via &lt;code&gt;waitUntilFreshAndBlock()&lt;&#x2F;code&gt;. Without this mechanism, you&#x27;d see 3-second hangs on every consistent read to quiet resources.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Progress notifications&lt;&#x2F;strong&gt; solve the critical problem of quiet resources: those that don&#x27;t receive updates for extended periods. These empty Watch responses update the cache&#x27;s revision without transferring data. Kubernetes implements this through two mechanisms: &lt;strong&gt;on-demand&lt;&#x2F;strong&gt; (explicit RequestProgress calls when the cache needs to catch up) and &lt;strong&gt;proactive&lt;&#x2F;strong&gt; (periodic monitoring by the progressRequester component).&lt;&#x2F;p&gt;
&lt;p&gt;Without progress notifications, consistent reads must bypass the cache entirely and go directly to etcd, significantly increasing load on the storage layer. This is the difference between a responsive cluster and one where every kubectl command feels sluggish.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;related-posts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#related-posts&quot; aria-label=&quot;Anchor link for: related-posts&quot;&gt;üîó&lt;&#x2F;a&gt;Related Posts&lt;&#x2F;h2&gt;
&lt;p&gt;If you enjoyed this deep dive into Kubernetes watch caching, you might also be interested in:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&#x2F;posts&#x2F;notes-about-etcd&#x2F;&quot;&gt;Notes about ETCD&lt;&#x2F;a&gt; - An overview and collection of resources about etcd, the distributed key-value store that powers Kubernetes&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;&#x2F;posts&#x2F;diving-into-etcd-linearizable&#x2F;&quot;&gt;Diving into ETCD&#x27;s linearizable reads&lt;&#x2F;a&gt; - A deep dive into how etcd implements linearizable reads using Raft consensus&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Feel free to reach out with any questions or to share your experiences with Kubernetes watch caching. You can find me on &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;PierreZ&quot;&gt;Twitter&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;bsky.app&#x2F;profile&#x2F;pierrezemb.fr&quot;&gt;Bluesky&lt;&#x2F;a&gt; or through my &lt;a href=&quot;https:&#x2F;&#x2F;pierrezemb.fr&quot;&gt;website&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
